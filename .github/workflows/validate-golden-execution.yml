name: Validate Golden Files (Execution)

on:
  pull_request:
    branches: [main]
    paths:
      - 'testdata/golden/plans/**/*.json'
      - 'scripts/validate-golden.sh'
      - 'scripts/regenerate-golden.sh'
      - '.github/workflows/validate-golden-execution.yml'
  workflow_dispatch:

jobs:
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      linux_matrix: ${{ steps.build-matrix.outputs.linux_matrix }}
      has_linux: ${{ steps.build-matrix.outputs.has_linux }}
      macos_files: ${{ steps.build-matrix.outputs.macos_files }}
      has_macos: ${{ steps.build-matrix.outputs.has_macos }}
      recipes: ${{ steps.build-matrix.outputs.recipes }}
      has_changes: ${{ steps.build-matrix.outputs.has_changes }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build execution matrix
        id: build-matrix
        run: |
          EXCLUSIONS_FILE="testdata/golden/exclusions.json"
          EXECUTION_EXCLUSIONS_FILE="testdata/golden/execution-exclusions.json"

          # Function to check if a recipe/platform is excluded (platform-specific exclusions)
          is_excluded() {
            local recipe="$1"
            local os="$2"
            local arch="$3"

            if [ ! -f "$EXCLUSIONS_FILE" ]; then
              return 1
            fi

            local filter=".exclusions[] | select(.recipe == \"$recipe\" and .platform.os == \"$os\" and .platform.arch == \"$arch\")"
            local match
            match=$(jq -r "$filter | .issue" "$EXCLUSIONS_FILE" 2>/dev/null | head -1)
            if [ -n "$match" ]; then
              echo "$match"
              return 0
            fi
            return 1
          }

          # Function to check if a recipe is excluded from execution validation entirely
          is_execution_excluded() {
            local recipe="$1"

            if [ ! -f "$EXECUTION_EXCLUSIONS_FILE" ]; then
              return 1
            fi

            local match
            match=$(jq -r --arg r "$recipe" '.exclusions[] | select(.recipe == $r) | .issue' "$EXECUTION_EXCLUSIONS_FILE" 2>/dev/null | head -1)
            if [ -n "$match" ]; then
              echo "$match"
              return 0
            fi
            return 1
          }

          # Get list of changed golden files (exclude deleted files)
          CHANGED=$(git diff --name-only --diff-filter=d origin/main...HEAD -- 'testdata/golden/plans/**/*.json')

          if [ -z "$CHANGED" ]; then
            echo "No golden files changed"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "has_linux=false" >> $GITHUB_OUTPUT
            echo "has_macos=false" >> $GITHUB_OUTPUT
            echo "linux_matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "macos_files=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Changed golden files:"
          echo "$CHANGED"

          # Build separate outputs for Linux (per-file matrix) and macOS (aggregated)
          LINUX_MATRIX='{"include":['
          MACOS_FILES='['
          LINUX_FIRST=true
          MACOS_FIRST=true

          for path in $CHANGED; do
            # Skip if file doesn't exist (deleted in later commit)
            if [ ! -f "$path" ]; then
              echo "Skipping deleted file: $path"
              continue
            fi

            # Extract platform from filename
            # Family-agnostic: v1.20.0-linux-amd64.json -> linux-amd64
            # Family-aware: v1.0.0-linux-debian-amd64.json -> linux-debian-amd64
            filename=$(basename "$path" .json)
            # Check if second-from-last component is a known family (e.g., "debian" in linux-debian-amd64)
            second_from_last=$(echo "$filename" | rev | cut -d'-' -f2 | rev)
            if [[ "$second_from_last" =~ ^(debian|rhel|arch|alpine|suse)$ ]]; then
              # Family-aware: extract os-family-arch
              platform=$(echo "$filename" | rev | cut -d'-' -f1-3 | rev)
            else
              # Family-agnostic: extract os-arch
              platform=$(echo "$filename" | rev | cut -d'-' -f1-2 | rev)
            fi

            # Extract tool name for job naming
            tool=$(basename "$(dirname "$path")")

            # Route to Linux matrix or macOS aggregated list
            case "$platform" in
              linux-amd64|linux-debian-amd64)
                # Check if excluded from execution validation entirely
                exec_exclusion=$(is_execution_excluded "$tool" || true)
                if [ -n "$exec_exclusion" ]; then
                  echo "Skipping $path (execution excluded: $exec_exclusion)"
                  continue
                fi
                # Check if platform-specific excluded
                exclusion_issue=$(is_excluded "$tool" "linux" "amd64" || true)
                if [ -n "$exclusion_issue" ]; then
                  echo "Skipping $path (excluded: $exclusion_issue)"
                  continue
                fi
                # Ubuntu runners are Debian-based - add to Linux matrix
                if [ "$LINUX_FIRST" = true ]; then
                  LINUX_FIRST=false
                else
                  LINUX_MATRIX="$LINUX_MATRIX,"
                fi
                LINUX_MATRIX="$LINUX_MATRIX{\"file\":\"$path\",\"os\":\"ubuntu-latest\",\"platform\":\"$platform\",\"tool\":\"$tool\",\"version\":\"$filename\"}"
                ;;
              linux-rhel-amd64|linux-arch-amd64|linux-alpine-amd64|linux-suse-amd64)
                # Skip: no matching GitHub-hosted runners
                echo "Skipping $path ($platform no matching runner)"
                ;;
              darwin-arm64)
                # Check if excluded from execution validation entirely
                exec_exclusion=$(is_execution_excluded "$tool" || true)
                if [ -n "$exec_exclusion" ]; then
                  echo "Skipping $path (execution excluded: $exec_exclusion)"
                  continue
                fi
                # Check if platform-specific excluded
                exclusion_issue=$(is_excluded "$tool" "darwin" "arm64" || true)
                if [ -n "$exclusion_issue" ]; then
                  echo "Skipping $path (excluded: $exclusion_issue)"
                  continue
                fi
                # Add to macOS aggregated list
                if [ "$MACOS_FIRST" = true ]; then
                  MACOS_FIRST=false
                else
                  MACOS_FILES="$MACOS_FILES,"
                fi
                MACOS_FILES="$MACOS_FILES{\"file\":\"$path\",\"tool\":\"$tool\",\"version\":\"$filename\"}"
                ;;
              darwin-amd64)
                # Skip: Intel Mac runners require paid tier
                echo "Skipping $path (darwin-amd64 requires paid tier)"
                ;;
              linux-arm64|linux-*-arm64)
                # Skip: no GitHub-hosted runners available
                echo "Skipping $path (linux-arm64 no runners available)"
                ;;
              *)
                echo "Unknown platform in $path: $platform"
                ;;
            esac
          done

          LINUX_MATRIX="$LINUX_MATRIX]}"
          MACOS_FILES="$MACOS_FILES]"

          # Set outputs
          if [ "$LINUX_MATRIX" = '{"include":[]}' ]; then
            echo "has_linux=false" >> $GITHUB_OUTPUT
          else
            echo "has_linux=true" >> $GITHUB_OUTPUT
          fi
          echo "linux_matrix=$LINUX_MATRIX" >> $GITHUB_OUTPUT

          if [ "$MACOS_FILES" = '[]' ]; then
            echo "has_macos=false" >> $GITHUB_OUTPUT
          else
            echo "has_macos=true" >> $GITHUB_OUTPUT
          fi
          echo "macos_files=$MACOS_FILES" >> $GITHUB_OUTPUT

          # Overall has_changes
          if [ "$LINUX_MATRIX" = '{"include":[]}' ] && [ "$MACOS_FILES" = '[]' ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

          # Extract unique recipe names for coverage validation (excluding execution-excluded recipes)
          ALL_RECIPES=$(echo "$CHANGED" | while read -r path; do
            if [ -n "$path" ]; then
              basename "$(dirname "$path")"
            fi
          done | sort -u)

          RECIPES='['
          RECIPES_FIRST=true
          for recipe in $ALL_RECIPES; do
            exec_exclusion=$(is_execution_excluded "$recipe" || true)
            if [ -n "$exec_exclusion" ]; then
              echo "Excluding recipe from coverage validation: $recipe ($exec_exclusion)"
              continue
            fi
            if [ "$RECIPES_FIRST" = true ]; then
              RECIPES_FIRST=false
            else
              RECIPES="$RECIPES,"
            fi
            RECIPES="$RECIPES\"$recipe\""
          done
          RECIPES="$RECIPES]"

          echo "Affected recipes: $RECIPES"
          echo "recipes=$RECIPES" >> $GITHUB_OUTPUT

  validate-coverage:
    name: "Coverage: ${{ matrix.recipe }}"
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        recipe: ${{ fromJson(needs.detect-changes.outputs.recipes) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Validate platform coverage
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RECIPE="${{ matrix.recipe }}"
          FIRST_LETTER="${RECIPE:0:1}"
          RECIPE_PATH="internal/recipe/recipes/$FIRST_LETTER/$RECIPE.toml"
          GOLDEN_DIR="testdata/golden/plans/$FIRST_LETTER/$RECIPE"
          EXCLUSIONS_FILE="testdata/golden/exclusions.json"

          # Function to check if a recipe/platform is excluded
          is_excluded() {
            local recipe="$1"
            local os="$2"
            local arch="$3"
            local family="$4"

            if [ ! -f "$EXCLUSIONS_FILE" ]; then
              return 1
            fi

            # Build jq filter for matching exclusions
            # Match: recipe AND os AND arch AND (family matches OR no family in exclusion)
            local filter
            if [ -n "$family" ]; then
              filter=".exclusions[] | select(.recipe == \"$recipe\" and .platform.os == \"$os\" and .platform.arch == \"$arch\" and (.platform.linux_family == \"$family\" or .platform.linux_family == null))"
            else
              filter=".exclusions[] | select(.recipe == \"$recipe\" and .platform.os == \"$os\" and .platform.arch == \"$arch\" and .platform.linux_family == null)"
            fi

            local match
            match=$(jq -r "$filter | .issue" "$EXCLUSIONS_FILE" 2>/dev/null | head -1)
            if [ -n "$match" ]; then
              echo "  (excluded: $match)"
              return 0
            fi
            return 1
          }

          # Get supported platforms as JSON objects (preserving linux_family if present)
          # Build platform descriptors (os:arch:family)
          PLATFORMS=""
          while IFS= read -r platform_json; do
            os=$(echo "$platform_json" | jq -r '.os')
            arch=$(echo "$platform_json" | jq -r '.arch')
            family=$(echo "$platform_json" | jq -r '.linux_family // empty')

            # Skip linux-arm64 (no CI runner)
            if [[ "$os" == "linux" && "$arch" == "arm64" ]]; then
              continue
            fi

            PLATFORMS="$PLATFORMS $os:$arch:$family"
          done < <(./tsuku info --recipe "$RECIPE_PATH" --metadata-only --json | jq -c '.supported_platforms[]')
          PLATFORMS=$(echo "$PLATFORMS" | xargs)

          # Get versions from existing golden files
          # Family-aware: v1.0.0-linux-debian-amd64.json -> version before last 3 components
          # Family-agnostic: v0.60.0-linux-amd64.json -> version before last 2 components
          VERSIONS=$(for f in "$GOLDEN_DIR"/*.json; do
            filename=$(basename "$f" .json)
            num_parts=$(echo "$filename" | tr '-' '\n' | wc -l)
            if [[ $num_parts -ge 4 ]]; then
              # Check second-from-last component for family (e.g., "debian" in linux-debian-amd64)
              second_from_last=$(echo "$filename" | rev | cut -d'-' -f2 | rev)
              if [[ "$second_from_last" =~ ^(debian|rhel|arch|alpine|suse)$ ]]; then
                # Family-aware: version is everything before os-family-arch
                echo "$filename" | rev | cut -d'-' -f4- | rev
              else
                # Family-agnostic: version is everything before os-arch
                echo "$filename" | rev | cut -d'-' -f3- | rev
              fi
            else
              echo "$filename" | rev | cut -d'-' -f3- | rev
            fi
          done 2>/dev/null | sort -u || true)

          if [ -z "$VERSIONS" ]; then
            echo "No golden files found in $GOLDEN_DIR"
            exit 1
          fi

          # Check all platform/version combinations have files
          MISSING=()
          EXCLUDED_COUNT=0
          for version in $VERSIONS; do
            for platform_desc in $PLATFORMS; do
              # Parse platform descriptor (os:arch:family)
              os="${platform_desc%%:*}"
              rest="${platform_desc#*:}"
              arch="${rest%%:*}"
              family="${rest#*:}"

              # Build expected filename
              if [[ -n "$family" ]]; then
                expected_file="${version}-${os}-${family}-${arch}.json"
              else
                expected_file="${version}-${os}-${arch}.json"
              fi

              if [ ! -f "$GOLDEN_DIR/$expected_file" ]; then
                # Check if this recipe/platform is excluded
                if is_excluded "$RECIPE" "$os" "$arch" "$family"; then
                  EXCLUDED_COUNT=$((EXCLUDED_COUNT + 1))
                else
                  MISSING+=("$GOLDEN_DIR/$expected_file")
                fi
              fi
            done
          done

          if [ ${#MISSING[@]} -gt 0 ]; then
            echo "ERROR: Missing golden files for supported platforms:"
            for f in "${MISSING[@]}"; do
              echo "  - $f"
            done
            echo ""
            echo "Generate missing files with:"
            echo "  gh workflow run generate-golden-files.yml -f recipe=$RECIPE -f commit_back=true -f branch=\$(git branch --show-current)"
            exit 1
          fi

          if [ $EXCLUDED_COUNT -gt 0 ]; then
            echo "All platforms covered for $RECIPE ($EXCLUDED_COUNT excluded)"
          else
            echo "All platforms covered for $RECIPE"
          fi

  # Validate Linux golden files (per-file matrix for visibility)
  validate-linux:
    name: "${{ matrix.tool }} (${{ matrix.platform }})"
    needs: detect-changes
    if: needs.detect-changes.outputs.has_linux == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.linux_matrix) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Cache downloads
        uses: actions/cache@v4
        with:
          path: ~/.tsuku/cache/downloads
          key: golden-execution-${{ matrix.platform }}-${{ hashFiles(matrix.file) }}
          restore-keys: |
            golden-execution-${{ matrix.platform }}-

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Execute golden file
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Executing: ${{ matrix.file }}"
          ./tsuku install --plan "${{ matrix.file }}" --force

  # Validate macOS golden files (aggregated into single job to reduce runner queue pressure)
  validate-macos:
    name: "macOS (darwin-arm64)"
    needs: detect-changes
    if: needs.detect-changes.outputs.has_macos == 'true'
    runs-on: macos-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku
        run: go build -o tsuku ./cmd/tsuku

      - name: Execute all macOS golden files
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FAILED=()
          FILES='${{ needs.detect-changes.outputs.macos_files }}'
          CACHE_DIR="${{ runner.temp }}/tsuku-cache/downloads"
          mkdir -p "$CACHE_DIR"

          # Use while loop with process substitution to handle JSON objects with spaces
          while IFS= read -r item; do
            file=$(echo "$item" | jq -r '.file')
            tool=$(echo "$item" | jq -r '.tool')
            version=$(echo "$item" | jq -r '.version')

            echo "::group::Executing $tool ($version)"

            # Fresh TSUKU_HOME per golden file with shared download cache
            export TSUKU_HOME="${{ runner.temp }}/tsuku-$tool-$version"
            mkdir -p "$TSUKU_HOME/cache"
            ln -s "$CACHE_DIR" "$TSUKU_HOME/cache/downloads"

            if ! ./tsuku install --plan "$file" --force; then
              FAILED+=("$tool ($version)")
            fi
            echo "::endgroup::"
          done < <(echo "$FILES" | jq -c '.[]')

          # Report failures at end (don't fail fast)
          if [ ${#FAILED[@]} -gt 0 ]; then
            echo "::error::Failed golden files: ${FAILED[*]}"
            exit 1
          fi

          echo "All macOS golden files passed"
