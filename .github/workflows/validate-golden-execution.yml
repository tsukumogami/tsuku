name: Validate Golden Files (Execution)

on:
  pull_request:
    branches: [main]
    paths:
      # Embedded golden files (still in git)
      - 'testdata/golden/plans/embedded/**/*.json'
      # Recipe changes trigger R2-based validation for registry recipes
      - 'recipes/**/*.toml'
      - 'scripts/validate-golden.sh'
      - 'scripts/regenerate-golden.sh'
      - '.github/workflows/validate-golden-execution.yml'
  workflow_dispatch:

jobs:
  # Check R2 availability for registry recipe execution validation
  r2-health-check:
    name: R2 Health Check
    runs-on: ubuntu-latest
    outputs:
      r2_available: ${{ steps.check.outputs.r2_available }}
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - name: Check R2 health
        id: check
        env:
          R2_BUCKET_URL: ${{ secrets.R2_BUCKET_URL }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID_READONLY }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY_READONLY }}
        run: |
          # Check if R2 credentials are configured
          if [[ -z "$R2_BUCKET_URL" ]] || [[ -z "$R2_ACCESS_KEY_ID" ]] || [[ -z "$R2_SECRET_ACCESS_KEY" ]]; then
            echo "::warning::R2 credentials not configured"
            echo "r2_available=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Checking R2 health..."
          if ./scripts/r2-health-check.sh; then
            echo "r2_available=true" >> $GITHUB_OUTPUT
          else
            echo "::warning::R2 health check failed"
            echo "r2_available=false" >> $GITHUB_OUTPUT
          fi

  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      linux_matrix: ${{ steps.build-matrix.outputs.linux_matrix }}
      has_linux: ${{ steps.build-matrix.outputs.has_linux }}
      macos_files: ${{ steps.build-matrix.outputs.macos_files }}
      has_macos: ${{ steps.build-matrix.outputs.has_macos }}
      container_files: ${{ steps.build-matrix.outputs.container_files }}
      has_container: ${{ steps.build-matrix.outputs.has_container }}
      recipes: ${{ steps.build-matrix.outputs.recipes }}
      has_changes: ${{ steps.build-matrix.outputs.has_changes }}
      registry_recipes: ${{ steps.build-matrix.outputs.registry_recipes }}
      has_registry_changes: ${{ steps.build-matrix.outputs.has_registry_changes }}
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4
        with:
          fetch-depth: 0

      - name: Build execution matrix
        id: build-matrix
        run: |
          EXCLUSIONS_FILE="testdata/golden/exclusions.json"
          EXECUTION_EXCLUSIONS_FILE="testdata/golden/execution-exclusions.json"

          # Function to check if a recipe/platform is excluded (platform-specific exclusions)
          is_excluded() {
            local recipe="$1"
            local os="$2"
            local arch="$3"

            if [ ! -f "$EXCLUSIONS_FILE" ]; then
              return 1
            fi

            local filter=".exclusions[] | select(.recipe == \"$recipe\" and .platform.os == \"$os\" and .platform.arch == \"$arch\")"
            local match
            match=$(jq -r "$filter | .issue" "$EXCLUSIONS_FILE" 2>/dev/null | head -1)
            if [ -n "$match" ]; then
              echo "$match"
              return 0
            fi
            return 1
          }

          # Function to check if a recipe is excluded from execution validation entirely
          is_execution_excluded() {
            local recipe="$1"

            if [ ! -f "$EXECUTION_EXCLUSIONS_FILE" ]; then
              return 1
            fi

            local match
            match=$(jq -r --arg r "$recipe" '.exclusions[] | select(.recipe == $r) | .issue' "$EXECUTION_EXCLUSIONS_FILE" 2>/dev/null | head -1)
            if [ -n "$match" ]; then
              echo "$match"
              return 0
            fi
            return 1
          }

          # Get list of changed embedded golden files (exclude deleted files)
          # Note: Registry golden files are now in R2, not git
          CHANGED_EMBEDDED=$(git diff --name-only --diff-filter=d origin/main...HEAD -- 'testdata/golden/plans/embedded/**/*.json')

          # Get list of changed registry recipes (for R2-based execution)
          CHANGED_REGISTRY_RECIPES=$(git diff --name-only --diff-filter=d origin/main...HEAD -- 'recipes/**/*.toml')

          # Process embedded golden file changes (existing logic)
          if [ -z "$CHANGED_EMBEDDED" ]; then
            echo "No embedded golden files changed"
          else
            echo "Changed embedded golden files:"
            echo "$CHANGED_EMBEDDED"
          fi

          # Process registry recipe changes
          REGISTRY_RECIPES='['
          REGISTRY_FIRST=true
          if [ -n "$CHANGED_REGISTRY_RECIPES" ]; then
            echo "Changed registry recipes:"
            echo "$CHANGED_REGISTRY_RECIPES"

            for path in $CHANGED_REGISTRY_RECIPES; do
              [ -f "$path" ] || continue
              recipe=$(basename "$path" .toml)

              exec_exclusion=$(is_execution_excluded "$recipe" || true)
              if [ -n "$exec_exclusion" ]; then
                echo "Skipping excluded recipe: $recipe ($exec_exclusion)"
                continue
              fi

              if [ "$REGISTRY_FIRST" = true ]; then
                REGISTRY_FIRST=false
              else
                REGISTRY_RECIPES="$REGISTRY_RECIPES,"
              fi
              REGISTRY_RECIPES="$REGISTRY_RECIPES\"$recipe\""
            done
          fi
          REGISTRY_RECIPES="$REGISTRY_RECIPES]"

          if [ "$REGISTRY_RECIPES" = '[]' ]; then
            echo "has_registry_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_registry_changes=true" >> $GITHUB_OUTPUT
          fi
          echo "registry_recipes=$REGISTRY_RECIPES" >> $GITHUB_OUTPUT

          # Build separate outputs for Linux (per-file matrix), macOS (aggregated), and containers (aggregated)
          # This processes embedded golden files only (registry uses R2)
          LINUX_MATRIX='{"include":['
          MACOS_FILES='['
          CONTAINER_FILES='['
          LINUX_FIRST=true
          MACOS_FIRST=true
          CONTAINER_FIRST=true

          for path in $CHANGED_EMBEDDED; do
            # Skip if file doesn't exist (deleted in later commit)
            if [ ! -f "$path" ]; then
              echo "Skipping deleted file: $path"
              continue
            fi

            # Extract platform from filename
            # Family-agnostic: v1.20.0-linux-amd64.json -> linux-amd64
            # Family-aware: v1.0.0-linux-debian-amd64.json -> linux-debian-amd64
            filename=$(basename "$path" .json)
            # Check if second-from-last component is a known family (e.g., "debian" in linux-debian-amd64)
            second_from_last=$(echo "$filename" | rev | cut -d'-' -f2 | rev)
            if [[ "$second_from_last" =~ ^(debian|rhel|arch|alpine|suse)$ ]]; then
              # Family-aware: extract os-family-arch
              platform=$(echo "$filename" | rev | cut -d'-' -f1-3 | rev)
            else
              # Family-agnostic: extract os-arch
              platform=$(echo "$filename" | rev | cut -d'-' -f1-2 | rev)
            fi

            # Extract tool name for job naming
            tool=$(basename "$(dirname "$path")")

            # Route to Linux matrix or macOS aggregated list
            case "$platform" in
              linux-amd64|linux-debian-amd64)
                # Check if excluded from execution validation entirely
                exec_exclusion=$(is_execution_excluded "$tool" || true)
                if [ -n "$exec_exclusion" ]; then
                  echo "Skipping $path (execution excluded: $exec_exclusion)"
                  continue
                fi
                # Check if platform-specific excluded
                exclusion_issue=$(is_excluded "$tool" "linux" "amd64" || true)
                if [ -n "$exclusion_issue" ]; then
                  echo "Skipping $path (excluded: $exclusion_issue)"
                  continue
                fi
                # Ubuntu runners are Debian-based - add to Linux matrix
                if [ "$LINUX_FIRST" = true ]; then
                  LINUX_FIRST=false
                else
                  LINUX_MATRIX="$LINUX_MATRIX,"
                fi
                LINUX_MATRIX="$LINUX_MATRIX{\"file\":\"$path\",\"os\":\"ubuntu-latest\",\"platform\":\"$platform\",\"tool\":\"$tool\",\"version\":\"$filename\"}"
                ;;
              linux-rhel-amd64|linux-arch-amd64|linux-alpine-amd64|linux-suse-amd64)
                # Check if excluded from execution validation entirely
                exec_exclusion=$(is_execution_excluded "$tool" || true)
                if [ -n "$exec_exclusion" ]; then
                  echo "Skipping $path (execution excluded: $exec_exclusion)"
                  continue
                fi
                # Extract family from platform (e.g., linux-alpine-amd64 -> alpine)
                family=$(echo "$platform" | cut -d'-' -f2)
                # Add to container aggregated list (runs in Docker)
                if [ "$CONTAINER_FIRST" = true ]; then
                  CONTAINER_FIRST=false
                else
                  CONTAINER_FILES="$CONTAINER_FILES,"
                fi
                CONTAINER_FILES="$CONTAINER_FILES{\"file\":\"$path\",\"tool\":\"$tool\",\"version\":\"$filename\",\"family\":\"$family\"}"
                ;;
              darwin-arm64)
                # Check if excluded from execution validation entirely
                exec_exclusion=$(is_execution_excluded "$tool" || true)
                if [ -n "$exec_exclusion" ]; then
                  echo "Skipping $path (execution excluded: $exec_exclusion)"
                  continue
                fi
                # Check if platform-specific excluded
                exclusion_issue=$(is_excluded "$tool" "darwin" "arm64" || true)
                if [ -n "$exclusion_issue" ]; then
                  echo "Skipping $path (excluded: $exclusion_issue)"
                  continue
                fi
                # Add to macOS aggregated list
                if [ "$MACOS_FIRST" = true ]; then
                  MACOS_FIRST=false
                else
                  MACOS_FILES="$MACOS_FILES,"
                fi
                MACOS_FILES="$MACOS_FILES{\"file\":\"$path\",\"tool\":\"$tool\",\"version\":\"$filename\"}"
                ;;
              darwin-amd64)
                # Skip: Intel Mac runners require paid tier
                echo "Skipping $path (darwin-amd64 requires paid tier)"
                ;;
              linux-arm64|linux-*-arm64)
                # Skip: no GitHub-hosted runners available
                echo "Skipping $path (linux-arm64 no runners available)"
                ;;
              *)
                echo "Unknown platform in $path: $platform"
                ;;
            esac
          done

          LINUX_MATRIX="$LINUX_MATRIX]}"
          MACOS_FILES="$MACOS_FILES]"
          CONTAINER_FILES="$CONTAINER_FILES]"

          # Set outputs
          if [ "$LINUX_MATRIX" = '{"include":[]}' ]; then
            echo "has_linux=false" >> $GITHUB_OUTPUT
          else
            echo "has_linux=true" >> $GITHUB_OUTPUT
          fi
          echo "linux_matrix=$LINUX_MATRIX" >> $GITHUB_OUTPUT

          if [ "$MACOS_FILES" = '[]' ]; then
            echo "has_macos=false" >> $GITHUB_OUTPUT
          else
            echo "has_macos=true" >> $GITHUB_OUTPUT
          fi
          echo "macos_files=$MACOS_FILES" >> $GITHUB_OUTPUT

          if [ "$CONTAINER_FILES" = '[]' ]; then
            echo "has_container=false" >> $GITHUB_OUTPUT
          else
            echo "has_container=true" >> $GITHUB_OUTPUT
          fi
          echo "container_files=$CONTAINER_FILES" >> $GITHUB_OUTPUT

          # Overall has_changes (embedded golden files)
          if [ "$LINUX_MATRIX" = '{"include":[]}' ] && [ "$MACOS_FILES" = '[]' ] && [ "$CONTAINER_FILES" = '[]' ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

          # Extract unique recipe names for coverage validation (excluding execution-excluded recipes)
          # Note: This is for embedded recipes only
          ALL_RECIPES=$(echo "$CHANGED_EMBEDDED" | while read -r path; do
            if [ -n "$path" ]; then
              basename "$(dirname "$path")"
            fi
          done | sort -u)

          RECIPES='['
          RECIPES_FIRST=true
          for recipe in $ALL_RECIPES; do
            exec_exclusion=$(is_execution_excluded "$recipe" || true)
            if [ -n "$exec_exclusion" ]; then
              echo "Excluding recipe from coverage validation: $recipe ($exec_exclusion)"
              continue
            fi
            if [ "$RECIPES_FIRST" = true ]; then
              RECIPES_FIRST=false
            else
              RECIPES="$RECIPES,"
            fi
            RECIPES="$RECIPES\"$recipe\""
          done
          RECIPES="$RECIPES]"

          echo "Affected embedded recipes: $RECIPES"
          echo "recipes=$RECIPES" >> $GITHUB_OUTPUT

  # Validate coverage for embedded recipes only
  validate-coverage:
    name: "Coverage: ${{ matrix.recipe }}"
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        recipe: ${{ fromJson(needs.detect-changes.outputs.recipes) }}
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - name: Set up Go
        uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff  # v5
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Validate platform coverage
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RECIPE="${{ matrix.recipe }}"

          # Embedded recipes use embedded path
          RECIPE_PATH="internal/recipe/recipes/$RECIPE.toml"
          GOLDEN_DIR="testdata/golden/plans/embedded/$RECIPE"
          EXCLUSIONS_FILE="testdata/golden/exclusions.json"

          # Function to check if a recipe/platform is excluded
          is_excluded() {
            local recipe="$1"
            local os="$2"
            local arch="$3"
            local family="$4"

            if [ ! -f "$EXCLUSIONS_FILE" ]; then
              return 1
            fi

            # Build jq filter for matching exclusions
            local filter
            if [ -n "$family" ]; then
              filter=".exclusions[] | select(.recipe == \"$recipe\" and .platform.os == \"$os\" and .platform.arch == \"$arch\" and (.platform.linux_family == \"$family\" or .platform.linux_family == null))"
            else
              filter=".exclusions[] | select(.recipe == \"$recipe\" and .platform.os == \"$os\" and .platform.arch == \"$arch\" and .platform.linux_family == null)"
            fi

            local match
            match=$(jq -r "$filter | .issue" "$EXCLUSIONS_FILE" 2>/dev/null | head -1)
            if [ -n "$match" ]; then
              echo "  (excluded: $match)"
              return 0
            fi
            return 1
          }

          # Get supported platforms as JSON objects
          PLATFORMS=""
          while IFS= read -r platform_json; do
            os=$(echo "$platform_json" | jq -r '.os')
            arch=$(echo "$platform_json" | jq -r '.arch')
            family=$(echo "$platform_json" | jq -r '.linux_family // empty')

            # Skip linux-arm64 (no CI runner)
            if [[ "$os" == "linux" && "$arch" == "arm64" ]]; then
              continue
            fi

            PLATFORMS="$PLATFORMS $os:$arch:$family"
          done < <(./tsuku info --recipe "$RECIPE_PATH" --metadata-only --json | jq -c '.supported_platforms[]')
          PLATFORMS=$(echo "$PLATFORMS" | xargs)

          # Get versions from existing golden files
          VERSIONS=$(for f in "$GOLDEN_DIR"/*.json; do
            filename=$(basename "$f" .json)
            num_parts=$(echo "$filename" | tr '-' '\n' | wc -l)
            if [[ $num_parts -ge 4 ]]; then
              second_from_last=$(echo "$filename" | rev | cut -d'-' -f2 | rev)
              if [[ "$second_from_last" =~ ^(debian|rhel|arch|alpine|suse)$ ]]; then
                echo "$filename" | rev | cut -d'-' -f4- | rev
              else
                echo "$filename" | rev | cut -d'-' -f3- | rev
              fi
            else
              echo "$filename" | rev | cut -d'-' -f3- | rev
            fi
          done 2>/dev/null | sort -u || true)

          if [ -z "$VERSIONS" ]; then
            echo "No golden files found in $GOLDEN_DIR"
            exit 1
          fi

          # Check all platform/version combinations have files
          MISSING=()
          EXCLUDED_COUNT=0
          for version in $VERSIONS; do
            for platform_desc in $PLATFORMS; do
              os="${platform_desc%%:*}"
              rest="${platform_desc#*:}"
              arch="${rest%%:*}"
              family="${rest#*:}"

              if [[ -n "$family" ]]; then
                expected_file="${version}-${os}-${family}-${arch}.json"
              else
                expected_file="${version}-${os}-${arch}.json"
              fi

              if [ ! -f "$GOLDEN_DIR/$expected_file" ]; then
                if is_excluded "$RECIPE" "$os" "$arch" "$family"; then
                  EXCLUDED_COUNT=$((EXCLUDED_COUNT + 1))
                else
                  MISSING+=("$GOLDEN_DIR/$expected_file")
                fi
              fi
            done
          done

          if [ ${#MISSING[@]} -gt 0 ]; then
            echo "ERROR: Missing golden files for supported platforms:"
            for f in "${MISSING[@]}"; do
              echo "  - $f"
            done
            exit 1
          fi

          if [ $EXCLUDED_COUNT -gt 0 ]; then
            echo "All platforms covered for $RECIPE ($EXCLUDED_COUNT excluded)"
          else
            echo "All platforms covered for $RECIPE"
          fi

  # Validate embedded Linux golden files (per-file matrix for visibility)
  validate-linux:
    name: "${{ matrix.tool }} (${{ matrix.platform }})"
    needs: detect-changes
    if: needs.detect-changes.outputs.has_linux == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.linux_matrix) }}
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - name: Set up Go
        uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff  # v5
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Cache downloads
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830  # v4
        with:
          path: ~/.tsuku/cache/downloads
          key: golden-execution-${{ matrix.platform }}-${{ hashFiles(matrix.file) }}
          restore-keys: |
            golden-execution-${{ matrix.platform }}-

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Execute golden file
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Executing: ${{ matrix.file }}"
          ./tsuku install --plan "${{ matrix.file }}" --force

  # Validate embedded macOS golden files (aggregated into single job)
  validate-macos:
    name: "macOS (darwin-arm64)"
    needs: detect-changes
    if: needs.detect-changes.outputs.has_macos == 'true'
    runs-on: macos-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - name: Set up Go
        uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff  # v5
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku
        run: go build -o tsuku ./cmd/tsuku

      - name: Execute all macOS golden files
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FAILED=()
          FILES='${{ needs.detect-changes.outputs.macos_files }}'
          CACHE_DIR="${{ runner.temp }}/tsuku-cache/downloads"
          mkdir -p "$CACHE_DIR"

          while IFS= read -r item; do
            file=$(echo "$item" | jq -r '.file')
            tool=$(echo "$item" | jq -r '.tool')
            version=$(echo "$item" | jq -r '.version')

            echo "::group::Executing $tool ($version)"

            export TSUKU_HOME="${{ runner.temp }}/tsuku-$tool-$version"
            mkdir -p "$TSUKU_HOME/cache"
            ln -s "$CACHE_DIR" "$TSUKU_HOME/cache/downloads"

            if ! ./tsuku install --plan "$file" --force; then
              FAILED+=("$tool ($version)")
            fi
            echo "::endgroup::"
          done < <(echo "$FILES" | jq -c '.[]')

          if [ ${#FAILED[@]} -gt 0 ]; then
            echo "::error::Failed golden files: ${FAILED[*]}"
            exit 1
          fi

          echo "All macOS golden files passed"

  # Validate embedded Linux golden files for non-Debian families (via Docker containers)
  # Uses docker run directly because GitHub Actions container: directive has issues with Alpine
  # (JavaScript actions don't work in musl-based containers)
  validate-linux-containers:
    name: "Linux Containers (${{ matrix.family }})"
    needs: detect-changes
    if: needs.detect-changes.outputs.has_container == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        family: [alpine, rhel, arch, suse]
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - name: Set up Go
        uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff  # v5
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku (static binary for containers)
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Execute golden files in container
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FAMILY="${{ matrix.family }}"
          FILES='${{ needs.detect-changes.outputs.container_files }}'

          # Map family to container image
          case "$FAMILY" in
            alpine) CONTAINER_IMAGE="alpine:3.21" ;;
            rhel)   CONTAINER_IMAGE="fedora:41" ;;
            arch)   CONTAINER_IMAGE="archlinux:base" ;;
            suse)   CONTAINER_IMAGE="opensuse/tumbleweed" ;;
            *)      echo "Unknown family: $FAMILY"; exit 1 ;;
          esac

          # Filter and format files for this family (parse JSON outside container)
          # Output format: file|tool|version (one per line)
          FILE_LIST=$(echo "$FILES" | jq -r ".[] | select(.family == \"$FAMILY\") | \"\(.file)|\(.tool)|\(.version)\"")

          if [ -z "$FILE_LIST" ]; then
            echo "No files to validate for $FAMILY"
            exit 0
          fi

          echo "Validating in $CONTAINER_IMAGE:"
          echo "$FILE_LIST" | cut -d'|' -f1

          # Run all golden files for this family in a single container
          # Pass file list via environment variable to avoid shell escaping issues
          docker run --rm \
            -v "$PWD:/workspace" \
            -e GITHUB_TOKEN="$GITHUB_TOKEN" \
            -e FILE_LIST="$FILE_LIST" \
            -e FAMILY="$FAMILY" \
            -w /workspace \
            "$CONTAINER_IMAGE" \
            sh -c '
              set -e
              FAILED=""

              # Pre-install system packages that apk_install actions will verify
              # This is needed because apk_install only checks packages, does not install them
              if [ "$FAMILY" = "alpine" ]; then
                echo "Pre-installing system packages for Alpine validation..."
                apk add --no-cache libstdc++ yaml-dev openssl-dev
              fi

              echo "$FILE_LIST" | while IFS="|" read -r file tool version; do
                echo "=== Executing $tool ($version) ==="

                # Use isolated TSUKU_HOME per tool
                export TSUKU_HOME="/tmp/tsuku-$tool-$version"
                mkdir -p "$TSUKU_HOME"

                if ! ./tsuku install --plan "$file" --force; then
                  echo "$tool" >> /tmp/failed_tools
                fi
              done

              if [ -f /tmp/failed_tools ]; then
                echo "Failed: $(cat /tmp/failed_tools | tr "\n" " ")"
                exit 1
              fi

              echo "All golden files passed"
            '

  # Execute registry recipes using golden files from R2
  execute-registry-linux:
    name: "Registry: ${{ matrix.recipe }} (Linux)"
    needs: [detect-changes, r2-health-check]
    if: needs.detect-changes.outputs.has_registry_changes == 'true' && needs.r2-health-check.outputs.r2_available == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        recipe: ${{ fromJson(needs.detect-changes.outputs.registry_recipes) }}
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - name: Set up Go
        uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff  # v5
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Cache downloads
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830  # v4
        with:
          path: ~/.tsuku/cache/downloads
          key: golden-execution-registry-${{ matrix.recipe }}
          restore-keys: |
            golden-execution-registry-

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Download golden file from R2
        env:
          R2_BUCKET_URL: ${{ secrets.R2_BUCKET_URL }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID_READONLY }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY_READONLY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID_READONLY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY_READONLY }}
          AWS_ENDPOINT_URL: ${{ secrets.R2_BUCKET_URL }}
        run: |
          RECIPE="${{ matrix.recipe }}"
          FIRST_LETTER="${RECIPE:0:1}"

          mkdir -p r2-golden

          # Find and download the latest linux-amd64 golden file
          # List versions available for this recipe
          VERSIONS=$(aws s3 ls "s3://tsuku-golden-registry/plans/$FIRST_LETTER/$RECIPE/" | grep 'PRE v' | awk '{print $2}' | sed 's|/$||' | sort -V | tail -1)

          if [ -z "$VERSIONS" ]; then
            echo "::warning::No golden files found in R2 for $RECIPE, skipping execution"
            exit 0
          fi

          echo "Latest version: $VERSIONS"

          # Download linux-amd64 golden file (prefer debian variant)
          GOLDEN_FILE=""
          for platform in "linux-debian-amd64" "linux-amd64"; do
            KEY="plans/$FIRST_LETTER/$RECIPE/$VERSIONS/$platform.json"
            if aws s3 cp "s3://tsuku-golden-registry/$KEY" "r2-golden/$platform.json" 2>/dev/null; then
              GOLDEN_FILE="r2-golden/$platform.json"
              echo "Downloaded: $KEY"
              break
            fi
          done

          if [ -z "$GOLDEN_FILE" ]; then
            echo "::warning::No Linux golden file found in R2 for $RECIPE $VERSIONS"
            exit 0
          fi

          echo "GOLDEN_FILE=$GOLDEN_FILE" >> $GITHUB_ENV

      - name: Execute golden file
        if: env.GOLDEN_FILE != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Executing: $GOLDEN_FILE"
          ./tsuku install --plan "$GOLDEN_FILE" --force

  # Skip registry execution when R2 is unavailable
  skip-registry-execution:
    name: "Registry Execution (R2 Unavailable)"
    needs: [detect-changes, r2-health-check]
    if: needs.detect-changes.outputs.has_registry_changes == 'true' && needs.r2-health-check.outputs.r2_available == 'false'
    runs-on: ubuntu-latest
    steps:
      - name: Report R2 unavailable
        run: |
          echo "::warning::R2 is unavailable - skipping registry recipe execution validation"
          echo "Registry recipes changed: ${{ needs.detect-changes.outputs.registry_recipes }}"
          echo "Execution validation for these recipes will be performed by nightly workflow"
