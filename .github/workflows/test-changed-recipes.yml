name: Test Changed Recipes

on:
  pull_request:
    branches: [main]
    paths:
      - 'internal/recipe/recipes/**/*.toml'
      - 'recipes/**/*.toml'
      - 'testdata/golden/execution-exclusions.json'
      - '.github/workflows/test-changed-recipes.yml'
  workflow_dispatch:
    inputs:
      batch_size_override:
        description: 'Override Linux batch size (1-50, 0 = use config default)'
        required: false
        type: number
        default: 0

jobs:
  # Detect changed recipes and generate matrix
  matrix:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      recipes: ${{ steps.changed.outputs.recipes }}
      has_changes: ${{ steps.changed.outputs.has_changes }}
      macos_recipes: ${{ steps.changed.outputs.macos_recipes }}
      has_macos: ${{ steps.changed.outputs.has_macos }}
      linux_batches: ${{ steps.batch.outputs.linux_batches }}
      has_linux_batches: ${{ steps.batch.outputs.has_linux_batches }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5  # v6.2.0
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Get changed recipes
        id: changed
        run: |
          EXECUTION_EXCLUSIONS_FILE="testdata/golden/execution-exclusions.json"

          # Function to check if a recipe is excluded from installation testing
          is_execution_excluded() {
            local recipe="$1"

            if [ ! -f "$EXECUTION_EXCLUSIONS_FILE" ]; then
              return 1
            fi

            local match
            match=$(jq -r --arg r "$recipe" '.exclusions[] | select(.recipe == $r) | .issue' "$EXECUTION_EXCLUSIONS_FILE" 2>/dev/null | head -1)
            if [ -n "$match" ]; then
              echo "$match"
              return 0
            fi
            return 1
          }

          # Get list of changed recipe files (exclude deleted files)
          # Check both embedded (internal/recipe/recipes) and registry (recipes/) locations
          CHANGED=$(git diff --name-only --diff-filter=d origin/main...HEAD -- 'internal/recipe/recipes/**/*.toml' 'recipes/**/*.toml')

          if [ -z "$CHANGED" ]; then
            echo "No recipe files changed"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "recipes=[]" >> $GITHUB_OUTPUT
            echo "has_macos=false" >> $GITHUB_OUTPUT
            echo "macos_recipes=[]" >> $GITHUB_OUTPUT
          else
            echo "Changed recipes:"
            echo "$CHANGED"

            # Build JSON arrays of {tool, path} objects per platform
            # Skip library recipes (type = "library") as they cannot be installed directly
            JSON="["
            MACOS_JSON="["
            FIRST=true
            MACOS_FIRST=true
            for path in $CHANGED; do
              # Skip if file doesn't exist (deleted in later commit)
              if [ ! -f "$path" ]; then
                echo "Skipping deleted recipe: $path"
                continue
              fi

              # Check if recipe is a library type
              if grep -q 'type = "library"' "$path" 2>/dev/null; then
                echo "Skipping library recipe: $path"
                continue
              fi

              # Check if recipe uses require_system (system dependencies can't be installed)
              if grep -q 'action = "require_system"' "$path" 2>/dev/null; then
                echo "Skipping system dependency recipe: $path"
                continue
              fi

              # Check if recipe is excluded from installation testing (toolchain issues)
              tool=$(basename "$path" .toml)
              exclusion_issue=$(is_execution_excluded "$tool" || true)
              if [ -n "$exclusion_issue" ]; then
                echo "Skipping excluded recipe: $tool ($exclusion_issue)"
                continue
              fi

              # Determine platform support using tsuku info
              has_linux="false"
              has_macos="false"
              if ! platforms=$(./tsuku info --json --metadata-only --recipe "$path" 2>/dev/null | jq -c '.supported_platforms // []'); then
                platforms="[]"
              fi

              if [ "$platforms" = "[]" ] || [ -z "$platforms" ]; then
                # No platform data or tsuku info failed: assume all platforms
                has_linux="true"
                has_macos="true"
                echo "All platforms (no constraints): $path"
              else
                if echo "$platforms" | jq -e '[.[] | select(.os == "linux")] | length > 0' > /dev/null 2>&1; then
                  has_linux="true"
                fi
                if echo "$platforms" | jq -e '[.[] | select(.os == "darwin")] | length > 0' > /dev/null 2>&1; then
                  has_macos="true"
                fi
                echo "Platform support for $tool: linux=$has_linux macos=$has_macos"
              fi

              # Add to Linux list if supported
              if [ "$has_linux" = "true" ]; then
                if [ "$FIRST" = true ]; then
                  FIRST=false
                else
                  JSON="$JSON,"
                fi
                JSON="$JSON{\"tool\":\"$tool\",\"path\":\"$path\"}"
              fi

              # Add to macOS list if supported
              if [ "$has_macos" = "true" ]; then
                if [ "$MACOS_FIRST" = true ]; then
                  MACOS_FIRST=false
                else
                  MACOS_JSON="$MACOS_JSON,"
                fi
                MACOS_JSON="$MACOS_JSON{\"tool\":\"$tool\",\"path\":\"$path\"}"
              fi
            done
            JSON="$JSON]"
            MACOS_JSON="$MACOS_JSON]"

            # Check if we have any non-library recipes
            if [ "$JSON" = "[]" ]; then
              echo "has_changes=false" >> $GITHUB_OUTPUT
            else
              echo "has_changes=true" >> $GITHUB_OUTPUT
            fi
            echo "recipes=$JSON" >> $GITHUB_OUTPUT

            # Check if we have any macOS-compatible recipes
            if [ "$MACOS_JSON" = "[]" ]; then
              echo "has_macos=false" >> $GITHUB_OUTPUT
            else
              echo "has_macos=true" >> $GITHUB_OUTPUT
            fi
            echo "macos_recipes=$MACOS_JSON" >> $GITHUB_OUTPUT
          fi

      - name: Split Linux recipes into batches
        id: batch
        run: |
          RECIPES='${{ steps.changed.outputs.recipes }}'

          # Handle empty or missing recipes
          if [ -z "$RECIPES" ] || [ "$RECIPES" = "[]" ]; then
            echo "linux_batches=[]" >> $GITHUB_OUTPUT
            echo "has_linux_batches=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Determine batch size: workflow_dispatch override > config file > default
          BATCH_SIZE=0
          OVERRIDE="${{ inputs.batch_size_override }}"
          if [ -n "$OVERRIDE" ] && [ "$OVERRIDE" != "0" ]; then
            BATCH_SIZE="$OVERRIDE"
            # Clamp to 1-50 range
            if [ "$BATCH_SIZE" -lt 1 ] 2>/dev/null; then
              echo "::warning::batch_size_override ($BATCH_SIZE) is below minimum, clamping to 1"
              BATCH_SIZE=1
            elif [ "$BATCH_SIZE" -gt 50 ] 2>/dev/null; then
              echo "::warning::batch_size_override ($BATCH_SIZE) exceeds maximum, clamping to 50"
              BATCH_SIZE=50
            fi
          fi

          # If no valid override, read from config file
          if [ "$BATCH_SIZE" -eq 0 ] 2>/dev/null || [ "$BATCH_SIZE" = "0" ]; then
            if [ -f .github/ci-batch-config.json ]; then
              BATCH_SIZE=$(jq -r '.batch_sizes["test-changed-recipes"].linux // 15' .github/ci-batch-config.json)
            else
              BATCH_SIZE=15
            fi
          fi

          echo "Using batch size: $BATCH_SIZE"

          # Split recipes into batches using ceiling division
          BATCHES=$(echo "$RECIPES" | jq -c --argjson bs "$BATCH_SIZE" '
            . as $all |
            [range(0; length; $bs)] |
            to_entries |
            map({batch_id: .key, recipes: $all[.value:.value + $bs]})
          ')

          echo "linux_batches=$BATCHES" >> $GITHUB_OUTPUT

          BATCH_COUNT=$(echo "$BATCHES" | jq 'length')
          if [ "$BATCH_COUNT" -gt 0 ]; then
            echo "has_linux_batches=true" >> $GITHUB_OUTPUT
          else
            echo "has_linux_batches=false" >> $GITHUB_OUTPUT
          fi

          echo "Generated $BATCH_COUNT Linux batches"

  # Test Linux recipes in batches (each batch builds once and tests multiple recipes)
  test-linux:
    name: "Linux batch ${{ matrix.batch.batch_id }}"
    needs: matrix
    if: ${{ needs.matrix.outputs.has_linux_batches == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        batch: ${{ fromJson(needs.matrix.outputs.linux_batches) }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5  # v6.2.0
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Test batch recipes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TSUKU_REGISTRY_URL: ${{ github.workspace }}
        run: |
          RECIPES='${{ toJson(matrix.batch.recipes) }}'
          CACHE_DIR="${{ runner.temp }}/tsuku-cache/downloads"
          FAIL_FILE="${{ runner.temp }}/failed-recipes.txt"
          mkdir -p "$CACHE_DIR"
          : > "$FAIL_FILE"

          COUNT=$(echo "$RECIPES" | jq 'length')
          for i in $(seq 0 $((COUNT - 1))); do
            tool=$(echo "$RECIPES" | jq -r ".[$i].tool")
            recipe_path=$(echo "$RECIPES" | jq -r ".[$i].path")
            echo "::group::Testing $tool"

            # Fresh TSUKU_HOME per recipe with shared download cache
            export TSUKU_HOME="${{ runner.temp }}/tsuku-$tool"
            mkdir -p "$TSUKU_HOME/cache"
            ln -s "$CACHE_DIR" "$TSUKU_HOME/cache/downloads"
            export PATH="$TSUKU_HOME/bin:$PATH"

            if ! ./tsuku install --force --recipe "$recipe_path"; then
              echo "$tool" >> "$FAIL_FILE"
            fi
            echo "::endgroup::"
          done

          # Report failures at end (don't fail fast)
          if [ -s "$FAIL_FILE" ]; then
            FAILED=$(cat "$FAIL_FILE" | tr '\n' ' ')
            echo "::error::Failed recipes: $FAILED"
            exit 1
          fi

          echo "All batch recipes passed"

  # Test all macOS-compatible recipes in a single job (reduces runner queue pressure)
  test-macos:
    name: "macOS (darwin-arm64)"
    needs: matrix
    if: ${{ needs.matrix.outputs.has_macos == 'true' }}
    runs-on: macos-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5  # v6.2.0
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Test all macOS recipes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TSUKU_REGISTRY_URL: ${{ github.workspace }}
        run: |
          RECIPES='${{ needs.matrix.outputs.macos_recipes }}'
          CACHE_DIR="${{ runner.temp }}/tsuku-cache/downloads"
          FAIL_FILE="${{ runner.temp }}/failed-recipes.txt"
          mkdir -p "$CACHE_DIR"
          : > "$FAIL_FILE"

          COUNT=$(echo "$RECIPES" | jq 'length')
          for i in $(seq 0 $((COUNT - 1))); do
            tool=$(echo "$RECIPES" | jq -r ".[$i].tool")
            recipe_path=$(echo "$RECIPES" | jq -r ".[$i].path")
            echo "::group::Testing $tool"

            # Fresh TSUKU_HOME per recipe with shared download cache
            export TSUKU_HOME="${{ runner.temp }}/tsuku-$tool"
            mkdir -p "$TSUKU_HOME/cache"
            ln -s "$CACHE_DIR" "$TSUKU_HOME/cache/downloads"
            echo "$TSUKU_HOME/bin" >> "$GITHUB_PATH"

            if ! ./tsuku install --force --recipe "$recipe_path"; then
              echo "$tool" >> "$FAIL_FILE"
            fi
            echo "::endgroup::"
          done

          # Report failures at end (don't fail fast)
          if [ -s "$FAIL_FILE" ]; then
            FAILED=$(cat "$FAIL_FILE" | tr '\n' ' ')
            echo "::error::Failed recipes: $FAILED"
            exit 1
          fi

          echo "All macOS recipes passed"
