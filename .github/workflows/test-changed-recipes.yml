name: Test Changed Recipes

on:
  pull_request:
    branches: [main]
    paths:
      - 'internal/recipe/recipes/**/*.toml'
      - 'recipes/**/*.toml'
      - 'testdata/golden/execution-exclusions.json'
      - '.github/workflows/test-changed-recipes.yml'
  workflow_dispatch:

jobs:
  # Detect changed recipes and generate matrix
  matrix:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      recipes: ${{ steps.changed.outputs.recipes }}
      has_changes: ${{ steps.changed.outputs.has_changes }}
      macos_recipes: ${{ steps.changed.outputs.macos_recipes }}
      has_macos: ${{ steps.changed.outputs.has_macos }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed recipes
        id: changed
        run: |
          EXECUTION_EXCLUSIONS_FILE="testdata/golden/execution-exclusions.json"

          # Function to check if a recipe is excluded from installation testing
          is_execution_excluded() {
            local recipe="$1"

            if [ ! -f "$EXECUTION_EXCLUSIONS_FILE" ]; then
              return 1
            fi

            local match
            match=$(jq -r --arg r "$recipe" '.exclusions[] | select(.recipe == $r) | .issue' "$EXECUTION_EXCLUSIONS_FILE" 2>/dev/null | head -1)
            if [ -n "$match" ]; then
              echo "$match"
              return 0
            fi
            return 1
          }

          # Get list of changed recipe files (exclude deleted files)
          # Check both embedded (internal/recipe/recipes) and registry (recipes/) locations
          CHANGED=$(git diff --name-only --diff-filter=d origin/main...HEAD -- 'internal/recipe/recipes/**/*.toml' 'recipes/**/*.toml')

          if [ -z "$CHANGED" ]; then
            echo "No recipe files changed"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "recipes=[]" >> $GITHUB_OUTPUT
            echo "has_macos=false" >> $GITHUB_OUTPUT
            echo "macos_recipes=[]" >> $GITHUB_OUTPUT
          else
            echo "Changed recipes:"
            echo "$CHANGED"

            # Build JSON array of {tool, path, linux_only} objects
            # Skip library recipes (type = "library") as they cannot be installed directly
            JSON="["
            MACOS_JSON="["
            FIRST=true
            MACOS_FIRST=true
            for path in $CHANGED; do
              # Skip if file doesn't exist (deleted in later commit)
              if [ ! -f "$path" ]; then
                echo "Skipping deleted recipe: $path"
                continue
              fi

              # Check if recipe is a library type
              if grep -q 'type = "library"' "$path" 2>/dev/null; then
                echo "Skipping library recipe: $path"
                continue
              fi

              # Check if recipe uses require_system (system dependencies can't be installed)
              if grep -q 'action = "require_system"' "$path" 2>/dev/null; then
                echo "Skipping system dependency recipe: $path"
                continue
              fi

              # Check if recipe is excluded from installation testing (toolchain issues)
              tool=$(basename "$path" .toml)
              exclusion_issue=$(is_execution_excluded "$tool" || true)
              if [ -n "$exclusion_issue" ]; then
                echo "Skipping excluded recipe: $tool ($exclusion_issue)"
                continue
              fi

              # Check if recipe is Linux-only
              # Method 1: Check supported_os field (new platform-aware format)
              # Method 2: Check os_mapping (legacy format)
              linux_only="false"
              if grep -q 'supported_os.*=.*\["linux"\]' "$path" 2>/dev/null; then
                linux_only="true"
                echo "Linux-only recipe (supported_os): $path"
              elif grep -q 'os_mapping.*linux' "$path" 2>/dev/null; then
                if ! grep -q 'os_mapping.*darwin' "$path" 2>/dev/null; then
                  linux_only="true"
                  echo "Linux-only recipe (os_mapping): $path"
                fi
              fi

              if [ "$FIRST" = true ]; then
                FIRST=false
              else
                JSON="$JSON,"
              fi
              JSON="$JSON{\"tool\":\"$tool\",\"path\":\"$path\",\"linux_only\":$linux_only}"

              # Add to macOS list if not Linux-only
              if [ "$linux_only" = "false" ]; then
                if [ "$MACOS_FIRST" = true ]; then
                  MACOS_FIRST=false
                else
                  MACOS_JSON="$MACOS_JSON,"
                fi
                MACOS_JSON="$MACOS_JSON\"$tool\""
              fi
            done
            JSON="$JSON]"
            MACOS_JSON="$MACOS_JSON]"

            # Check if we have any non-library recipes
            if [ "$JSON" = "[]" ]; then
              echo "has_changes=false" >> $GITHUB_OUTPUT
            else
              echo "has_changes=true" >> $GITHUB_OUTPUT
            fi
            echo "recipes=$JSON" >> $GITHUB_OUTPUT

            # Check if we have any macOS-compatible recipes
            if [ "$MACOS_JSON" = "[]" ]; then
              echo "has_macos=false" >> $GITHUB_OUTPUT
            else
              echo "has_macos=true" >> $GITHUB_OUTPUT
            fi
            echo "macos_recipes=$MACOS_JSON" >> $GITHUB_OUTPUT
          fi

  # Test each changed recipe on Linux
  test-linux:
    name: "Linux: ${{ matrix.recipe.tool }}"
    needs: matrix
    if: ${{ needs.matrix.outputs.has_changes == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        recipe: ${{ fromJson(needs.matrix.outputs.recipes) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Setup PATH
        run: echo "$HOME/.tsuku/bin" >> $GITHUB_PATH

      - name: "Install ${{ matrix.recipe.tool }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: ./tsuku install --force --recipe ${{ matrix.recipe.path }}

  # Test all macOS-compatible recipes in a single job (reduces runner queue pressure)
  test-macos:
    name: "macOS (darwin-arm64)"
    needs: matrix
    if: ${{ needs.matrix.outputs.has_macos == 'true' }}
    runs-on: macos-latest
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Test all macOS recipes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FAILED=()
          RECIPES='${{ needs.matrix.outputs.macos_recipes }}'
          CACHE_DIR="${{ runner.temp }}/tsuku-cache/downloads"
          mkdir -p "$CACHE_DIR"

          for recipe in $(echo "$RECIPES" | jq -r '.[]'); do
            echo "::group::Testing $recipe"

            # Derive recipe file path from tool name
            first_letter=$(echo "$recipe" | cut -c1)
            recipe_path="recipes/$first_letter/$recipe.toml"

            # Fresh TSUKU_HOME per recipe with shared download cache
            export TSUKU_HOME="${{ runner.temp }}/tsuku-$recipe"
            mkdir -p "$TSUKU_HOME/cache"
            ln -s "$CACHE_DIR" "$TSUKU_HOME/cache/downloads"
            echo "$TSUKU_HOME/bin" >> "$GITHUB_PATH"

            if ! ./tsuku install --force --recipe "$recipe_path"; then
              FAILED+=("$recipe")
            fi
            echo "::endgroup::"
          done

          # Report failures at end (don't fail fast)
          if [ ${#FAILED[@]} -gt 0 ]; then
            echo "::error::Failed recipes: ${FAILED[*]}"
            exit 1
          fi

          echo "All macOS recipes passed"
