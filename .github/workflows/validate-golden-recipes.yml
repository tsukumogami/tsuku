name: Validate Golden Files (Recipes)

on:
  push:
    # no-op: explicit push trigger prevents ghost runs from stale workflow
    # registration (see #1844). The path filter never matches real files.
    paths:
      - '.github/non-existent-path-do-not-create'
  pull_request:
    branches: [main]
    paths:
      - 'internal/recipe/recipes/**/*.toml'
      - 'recipes/**/*.toml'
      - 'testdata/golden/exclusions.json'
      - '.github/workflows/validate-golden-recipes.yml'
  workflow_dispatch:
    inputs:
      batch_size_override:
        description: 'Override batch size (1-50, 0 = use config default)'
        required: false
        type: number
        default: 0

jobs:
  validate-exclusions:
    name: Validate Exclusions
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: Check for stale exclusions
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: ./scripts/validate-golden-exclusions.sh --check-issues

  # Check R2 availability for registry recipe validation
  r2-health-check:
    name: R2 Health Check
    runs-on: ubuntu-latest
    outputs:
      r2_available: ${{ steps.check.outputs.r2_available }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: Check R2 health
        id: check
        env:
          R2_BUCKET_URL: ${{ secrets.R2_BUCKET_URL }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID_READONLY }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY_READONLY }}
        run: |
          # Check if R2 credentials are configured
          if [[ -z "$R2_BUCKET_URL" ]] || [[ -z "$R2_ACCESS_KEY_ID" ]] || [[ -z "$R2_SECRET_ACCESS_KEY" ]]; then
            echo "::warning::R2 credentials not configured, registry validation will use git fallback"
            echo "r2_available=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Checking R2 health..."
          if ./scripts/r2-health-check.sh; then
            echo "r2_available=true" >> $GITHUB_OUTPUT
          else
            echo "::warning::R2 health check failed, registry validation will use git fallback"
            echo "r2_available=false" >> $GITHUB_OUTPUT
          fi

  detect-changes:
    name: Detect Changes
    needs: validate-exclusions
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.changed.outputs.has_changes }}
      batches: ${{ steps.batch.outputs.batches }}
      batch_count: ${{ steps.batch.outputs.batch_count }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          fetch-depth: 0

      - name: Get changed recipes
        id: changed
        run: |
          # Get list of changed recipe files (exclude deleted files)
          # Check both embedded (internal/recipe/recipes) and registry (recipes/) locations
          CHANGED=$(git diff --name-only --diff-filter=d origin/main...HEAD -- 'internal/recipe/recipes/**/*.toml' 'recipes/**/*.toml')

          if [ -z "$CHANGED" ]; then
            echo "No recipe files changed"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "recipes=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Changed recipes:"
          echo "$CHANGED"

          # Build JSON array of {recipe, category} objects
          # All recipes must have golden files - fail if any are missing
          JSON="["
          FIRST=true
          for path in $CHANGED; do
            # Skip if file doesn't exist (deleted in later commit)
            if [ ! -f "$path" ]; then
              echo "Skipping deleted recipe: $path"
              continue
            fi

            recipe=$(basename "$path" .toml)

            # Detect category from path and determine golden directory
            if [[ "$path" == internal/recipe/recipes/* ]]; then
              category="embedded"
              golden_dir="testdata/golden/plans/embedded/$recipe"
            else
              category="registry"
              first_letter="${recipe:0:1}"
              golden_dir="testdata/golden/plans/$first_letter/$recipe"
            fi

            # Check if recipe has golden files (for embedded recipes only - registry uses R2)
            # For registry recipes, we'll validate using TSUKU_GOLDEN_SOURCE=r2
            if [[ "$category" == "embedded" ]] && [ ! -d "$golden_dir" ]; then
              # Check if recipe is fully excluded (has exclusions for all platforms)
              exclusion_count=$(jq --arg r "$recipe" '[.exclusions[] | select(.recipe == $r)] | length' testdata/golden/exclusions.json)
              if [ "$exclusion_count" -gt 0 ]; then
                echo "Recipe '$recipe' has no golden files but is excluded ($exclusion_count exclusion(s))"
                continue
              fi
              echo "::error::Recipe '$recipe' has no golden files. Run './scripts/regenerate-golden.sh $recipe --category $category' to generate them."
              echo "::error::Or add exclusions to testdata/golden/exclusions.json with a tracking issue."
              exit 1
            fi

            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              JSON="$JSON,"
            fi
            JSON="$JSON{\"recipe\":\"$recipe\",\"category\":\"$category\"}"
          done
          JSON="$JSON]"

          if [ "$JSON" = "[]" ]; then
            echo "No recipes with golden files changed"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi
          echo "recipes=$JSON" >> $GITHUB_OUTPUT

      - name: Split recipes into batches
        id: batch
        run: |
          RECIPES='${{ steps.changed.outputs.recipes }}'

          # Handle empty or missing recipes
          if [ -z "$RECIPES" ] || [ "$RECIPES" = "[]" ]; then
            echo "batches=[]" >> $GITHUB_OUTPUT
            echo "batch_count=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Determine batch size: workflow_dispatch override > config file > default
          BATCH_SIZE=0
          OVERRIDE="${{ inputs.batch_size_override }}"
          if [ -n "$OVERRIDE" ] && [ "$OVERRIDE" != "0" ]; then
            BATCH_SIZE="$OVERRIDE"
            # Clamp to 1-50 range
            if [ "$BATCH_SIZE" -lt 1 ] 2>/dev/null; then
              echo "::warning::batch_size_override ($BATCH_SIZE) is below minimum, clamping to 1"
              BATCH_SIZE=1
            elif [ "$BATCH_SIZE" -gt 50 ] 2>/dev/null; then
              echo "::warning::batch_size_override ($BATCH_SIZE) exceeds maximum, clamping to 50"
              BATCH_SIZE=50
            fi
          fi

          # If no valid override, read from config file
          if [ "$BATCH_SIZE" -eq 0 ] 2>/dev/null || [ "$BATCH_SIZE" = "0" ]; then
            if [ -f .github/ci-batch-config.json ]; then
              BATCH_SIZE=$(jq -r '.batch_sizes["validate-golden-recipes"].default // 20' .github/ci-batch-config.json)
            else
              BATCH_SIZE=20
            fi
          fi

          echo "Using batch size: $BATCH_SIZE"

          # Split recipes into batches using ceiling division
          BATCHES=$(echo "$RECIPES" | jq -c --argjson bs "$BATCH_SIZE" '
            . as $all |
            [range(0; length; $bs)] |
            to_entries |
            map({batch_id: .key, recipes: $all[.value:.value + $bs]})
          ')

          echo "batches=$BATCHES" >> $GITHUB_OUTPUT

          BATCH_COUNT=$(echo "$BATCHES" | jq 'length')
          echo "batch_count=$BATCH_COUNT" >> $GITHUB_OUTPUT

          echo "Generated $BATCH_COUNT batches"

  validate-golden:
    name: "Validate (batch ${{ matrix.batch.batch_id + 1 }}/${{ needs.detect-changes.outputs.batch_count }})"
    needs: [detect-changes, r2-health-check]
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        batch: ${{ fromJson(needs.detect-changes.outputs.batches) }}
    env:
      R2_BUCKET_URL: ${{ secrets.R2_BUCKET_URL }}
      R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID_READONLY }}
      R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY_READONLY }}
      R2_AVAILABLE: ${{ needs.r2-health-check.outputs.r2_available }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5  # v6.2.0
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Validate batch recipes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RECIPES='${{ toJson(matrix.batch.recipes) }}'
          FAIL_FILE="${{ runner.temp }}/failed-recipes.txt"
          : > "$FAIL_FILE"

          COUNT=$(echo "$RECIPES" | jq 'length')
          for i in $(seq 0 $((COUNT - 1))); do
            RECIPE=$(echo "$RECIPES" | jq -r ".[$i].recipe")
            CATEGORY=$(echo "$RECIPES" | jq -r ".[$i].category")
            echo "::group::Validate $RECIPE"

            echo "Validating golden files for $RECIPE ($CATEGORY)..."

            # Determine golden source based on category and R2 availability
            if [[ "$CATEGORY" == "embedded" ]]; then
              # Embedded recipes always use git
              export TSUKU_GOLDEN_SOURCE=git
            elif [[ "$R2_AVAILABLE" == "true" ]]; then
              # Registry recipes use R2 when available
              export TSUKU_GOLDEN_SOURCE=r2

              # Check if golden files exist in R2 for this recipe
              # New recipes won't have golden files yet - skip validation with notice
              if ! ./scripts/check-golden-exists.sh "$RECIPE" --category "$CATEGORY"; then
                echo "::notice::Skipping validation for new recipe '$RECIPE' - golden files will be generated after merge"
                echo "::endgroup::"
                continue
              fi
            else
              # R2 unavailable - skip registry recipe validation with warning
              echo "::warning::Skipping $RECIPE validation - R2 unavailable (registry recipes require R2 golden files)"
              echo "Registry recipe validation will be performed by nightly workflow when R2 is available"
              echo "::endgroup::"
              continue
            fi

            echo "Using TSUKU_GOLDEN_SOURCE=$TSUKU_GOLDEN_SOURCE"

            if ! ./scripts/validate-golden.sh "$RECIPE" --category "$CATEGORY"; then
              echo ""
              echo "::error::Golden files are out of date for recipe '$RECIPE'."
              if [[ "$CATEGORY" == "embedded" ]]; then
                echo "::error::Run './scripts/regenerate-golden.sh $RECIPE --category $CATEGORY' and commit the changes."
              else
                echo "::error::Golden files in R2 don't match. The post-merge workflow will regenerate them after merge."
                echo "::error::If this is unexpected, check that the recipe changes are correct."
              fi
              echo "$RECIPE" >> "$FAIL_FILE"
            fi

            echo "::endgroup::"
          done

          # Report failures at end (don't fail fast)
          if [ -s "$FAIL_FILE" ]; then
            FAILED=$(cat "$FAIL_FILE" | tr '\n' ' ')
            echo "::error::Failed recipes: $FAILED"
            exit 1
          fi

          echo "All batch recipes passed"
