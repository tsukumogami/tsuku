name: Batch Recipe Generation
on:
  schedule:
    - cron: '0 * * * *'
  workflow_dispatch:
    inputs:
      ecosystem:
        description: 'Ecosystem to process'
        required: true
        default: 'homebrew'
        type: choice
        options:
          - homebrew
          - cargo
          - npm
          - pypi
          - rubygems
          - go
          - cpan
          - cask
      batch_size:
        description: 'Max recipes per run'
        required: true
        default: '25'
      tier:
        description: 'Queue tier (1=critical, 2=popular, 3=all)'
        required: true
        default: '3'
        type: choice
        options: ['1', '2', '3']

env:
  ECOSYSTEM: ${{ inputs.ecosystem || 'homebrew' }}
  BATCH_SIZE: ${{ inputs.batch_size || '10' }}
  TIER: ${{ inputs.tier || '3' }}

concurrency:
  group: queue-operations-${{ inputs.ecosystem || 'homebrew' }}
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write

jobs:
  generate:
    runs-on: ubuntu-latest
    outputs:
      has_recipes: ${{ steps.check.outputs.changes }}
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      # Generate short-lived GitHub App token for PR creation and git operations.
      # Provides automatic rotation (60min expiry), scoped permissions, and audit trail.
      # Replaces long-lived PAT to reduce credential exposure risk.
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@df04723f4af75c05d0338a8c9f2a62f7e1b69b5c  # v2
        with:
          app-id: ${{ secrets.TSUKU_BATCH_GENERATOR_APP_ID }}
          private-key: ${{ secrets.TSUKU_BATCH_GENERATOR_APP_PRIVATE_KEY }}

      - name: Preflight circuit breaker check
        id: preflight
        run: |
          STATE=$(jq -r --arg eco "${{ env.ECOSYSTEM }}" \
            '.circuit_breaker[$eco].state // "closed"' batch-control.json)

          if [ "$STATE" = "open" ]; then
            OPENS_AT=$(jq -r --arg eco "${{ env.ECOSYSTEM }}" \
              '.circuit_breaker[$eco].opens_at // ""' batch-control.json)
            NOW=$(date -u +%Y-%m-%dT%H:%M:%SZ)

            if [ -n "$OPENS_AT" ] && [[ "$NOW" > "$OPENS_AT" ]]; then
              # Timeout expired: transition to half-open for probe
              jq --arg eco "${{ env.ECOSYSTEM }}" --arg now "$NOW" \
                '.circuit_breaker[$eco].state = "half-open"' \
                batch-control.json > batch-control.tmp && mv batch-control.tmp batch-control.json
              STATE="half-open"
              echo "::notice::Circuit breaker transitioned to half-open for ${{ env.ECOSYSTEM }} (recovery timeout expired). Running probe batch (size=1)."
              echo "batch_size_override=1" >> "$GITHUB_OUTPUT"
            else
              FAILURES=$(jq -r --arg eco "${{ env.ECOSYSTEM }}" \
                '.circuit_breaker[$eco].failures // 0' batch-control.json)
              echo "::error::Circuit breaker is OPEN for ${{ env.ECOSYSTEM }} (${FAILURES} consecutive failures, recovery at: ${OPENS_AT}). Skipping batch generation."
              exit 1
            fi
          fi

          if [ "$STATE" = "half-open" ]; then
            echo "Circuit breaker is half-open for ${{ env.ECOSYSTEM }}. Running probe batch (size=1)."
            echo "batch_size_override=1" >> "$GITHUB_OUTPUT"
          else
            echo "Circuit breaker check passed for ${{ env.ECOSYSTEM }} (state: ${STATE})"
          fi

      - uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff  # v5
        with:
          go-version-file: go.mod

      - name: Build binaries
        run: |
          go build -o batch-generate ./cmd/batch-generate
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o tsuku-linux-amd64 ./cmd/tsuku
          CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -o tsuku-linux-arm64 ./cmd/tsuku
          CGO_ENABLED=0 GOOS=darwin GOARCH=arm64 go build -o tsuku-darwin-arm64 ./cmd/tsuku
          CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -o tsuku-darwin-amd64 ./cmd/tsuku
          cp tsuku-linux-amd64 tsuku
          echo "$PWD" >> "$GITHUB_PATH"

      - name: Run batch generation
        run: |
          OVERRIDE="${{ steps.preflight.outputs.batch_size_override }}"
          BATCH_SIZE="${OVERRIDE:-${{ env.BATCH_SIZE }}}"
          ./batch-generate \
            -ecosystem "${{ env.ECOSYSTEM }}" \
            -batch-size "$BATCH_SIZE" \
            -tier "${{ env.TIER }}"

      - name: Requeue unblocked packages
        run: ./scripts/requeue-unblocked.sh

      - name: Check for generated recipes
        id: check
        run: |
          if git diff --quiet && [ -z "$(git ls-files --others --exclude-standard recipes/)" ]; then
            echo "changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "changes=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Upload passing recipes
        if: steps.check.outputs.changes == 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4
        with:
          name: passing-recipes
          path: |
            recipes/
            data/
          retention-days: 1

      - name: Upload tsuku binaries
        if: steps.check.outputs.changes == 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4
        with:
          name: tsuku-binaries
          path: |
            tsuku-linux-amd64
            tsuku-linux-arm64
            tsuku-darwin-arm64
            tsuku-darwin-amd64
          retention-days: 1

  validate-linux-x86_64:
    needs: generate
    if: needs.generate.outputs.has_recipes == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 120
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        with:
          name: passing-recipes
          path: artifacts

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        with:
          name: tsuku-binaries

      - name: Make binary executable
        run: chmod +x tsuku-linux-amd64

      - name: Collect new recipe list
        id: recipes
        run: |
          # Find recipes that were generated (in artifacts but not in checkout)
          RECIPE_LIST=""
          for f in artifacts/recipes/*/*.toml; do
            basename_path="${f#artifacts/}"
            if [ ! -f "$basename_path" ]; then
              RECIPE_LIST="$RECIPE_LIST $basename_path"
            fi
          done
          echo "list=$RECIPE_LIST" >> "$GITHUB_OUTPUT"

      - name: Copy new recipes into working tree
        run: cp -r artifacts/recipes/* recipes/

      - name: Validate on all Linux x86_64 families
        run: |
          RESULTS="[]"
          IMAGES=("debian:bookworm-slim" "fedora:41" "archlinux:base" "opensuse/tumbleweed" "alpine:3.21")
          NAMES=("debian" "rhel" "arch" "suse" "alpine")
          LIBCS=("glibc" "glibc" "glibc" "glibc" "musl")

          for i in "${!IMAGES[@]}"; do
            image="${IMAGES[$i]}"
            family="${NAMES[$i]}"
            libc="${LIBCS[$i]}"
            platform="linux-${family}-${libc}-x86_64"

            echo "=== Validating on $platform ($image) ==="

            for recipe_path in ${{ steps.recipes.outputs.list }}; do
              recipe_name=$(basename "$recipe_path" .toml)

              case "$recipe_path" in
                *..*) echo "SKIP: path traversal in $recipe_path"; continue ;;
              esac

              echo "--- $recipe_name on $platform ---"
              STATUS="pass"
              EXIT_CODE=0
              ATTEMPTS=1

              for attempt in 0 1 2; do
                ATTEMPTS=$((attempt + 1))
                # Write tsuku exit code to file so Docker doesn't mask it
                docker run --rm \
                  -v "$PWD:/workspace" \
                  -w /workspace \
                  "$image" \
                  sh -c "
                    case '$family' in
                      alpine) apk add --no-cache curl bash ca-certificates ;;
                      debian) apt-get update && apt-get install -y --no-install-recommends curl ca-certificates ;;
                      rhel) dnf install -y --setopt=install_weak_deps=False curl ca-certificates ;;
                      arch) pacman -Sy --noconfirm curl ca-certificates ;;
                      suse) zypper -n install curl ca-certificates ;;
                    esac
                    timeout 300 ./tsuku-linux-amd64 install --force --recipe '$recipe_path'
                    echo \$? > /workspace/.tsuku-exit-code
                  " 2>&1 || true

                if [ -f .tsuku-exit-code ]; then
                  EXIT_CODE=$(cat .tsuku-exit-code)
                  rm -f .tsuku-exit-code
                else
                  # Container failed before running tsuku (Docker error)
                  EXIT_CODE=1
                fi

                if [ "$EXIT_CODE" = "0" ]; then
                  STATUS="pass"
                  break
                elif [ "$EXIT_CODE" = "5" ] && [ "$attempt" -lt 2 ]; then
                  echo "Network error, retrying (attempt $((attempt+2)))..."
                  sleep $((2 ** (attempt + 1)))
                  continue
                else
                  STATUS="fail"
                  break
                fi
              done

              RESULTS=$(echo "$RESULTS" | jq --arg r "$recipe_name" --arg p "$platform" \
                --arg s "$STATUS" --argjson e "$EXIT_CODE" --argjson a "$ATTEMPTS" \
                '. + [{"recipe": $r, "platform": $p, "status": $s, "exit_code": $e, "attempts": $a}]')
            done
          done

          echo "$RESULTS" > validation-results-linux-x86_64.json
          echo "### Linux x86_64 Validation Results" >> "$GITHUB_STEP_SUMMARY"
          echo '```json' >> "$GITHUB_STEP_SUMMARY"
          echo "$RESULTS" | jq . >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4
        with:
          name: validation-results-linux-x86_64
          path: validation-results-linux-x86_64.json
          retention-days: 1

  validate-linux-arm64:
    needs: generate
    if: needs.generate.outputs.has_recipes == 'true'
    runs-on: ubuntu-24.04-arm
    timeout-minutes: 120
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        with:
          name: passing-recipes
          path: artifacts

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        with:
          name: tsuku-binaries

      - name: Make binary executable
        run: chmod +x tsuku-linux-arm64

      - name: Collect new recipe list
        id: recipes
        run: |
          RECIPE_LIST=""
          for f in artifacts/recipes/*/*.toml; do
            basename_path="${f#artifacts/}"
            if [ ! -f "$basename_path" ]; then
              RECIPE_LIST="$RECIPE_LIST $basename_path"
            fi
          done
          echo "list=$RECIPE_LIST" >> "$GITHUB_OUTPUT"

      - name: Copy new recipes into working tree
        run: cp -r artifacts/recipes/* recipes/

      - name: Validate on all Linux arm64 families
        run: |
          RESULTS="[]"
          # archlinux:base excluded -- no ARM64 container image
          IMAGES=("debian:bookworm-slim" "fedora:41" "opensuse/tumbleweed" "alpine:3.21")
          NAMES=("debian" "rhel" "suse" "alpine")
          LIBCS=("glibc" "glibc" "glibc" "musl")

          for i in "${!IMAGES[@]}"; do
            image="${IMAGES[$i]}"
            family="${NAMES[$i]}"
            libc="${LIBCS[$i]}"
            platform="linux-${family}-${libc}-arm64"

            echo "=== Validating on $platform ($image) ==="

            for recipe_path in ${{ steps.recipes.outputs.list }}; do
              recipe_name=$(basename "$recipe_path" .toml)

              case "$recipe_path" in
                *..*) echo "SKIP: path traversal in $recipe_path"; continue ;;
              esac

              echo "--- $recipe_name on $platform ---"
              STATUS="pass"
              EXIT_CODE=0
              ATTEMPTS=1

              for attempt in 0 1 2; do
                ATTEMPTS=$((attempt + 1))
                docker run --rm \
                  -v "$PWD:/workspace" \
                  -w /workspace \
                  "$image" \
                  sh -c "
                    case '$family' in
                      alpine) apk add --no-cache curl bash ca-certificates ;;
                      debian) apt-get update && apt-get install -y --no-install-recommends curl ca-certificates ;;
                      rhel) dnf install -y --setopt=install_weak_deps=False curl ca-certificates ;;
                      suse) zypper -n install curl ca-certificates ;;
                    esac
                    timeout 300 ./tsuku-linux-arm64 install --force --recipe '$recipe_path'
                    echo \$? > /workspace/.tsuku-exit-code
                  " 2>&1 || true

                if [ -f .tsuku-exit-code ]; then
                  EXIT_CODE=$(cat .tsuku-exit-code)
                  rm -f .tsuku-exit-code
                else
                  EXIT_CODE=1
                fi

                if [ "$EXIT_CODE" = "0" ]; then
                  STATUS="pass"
                  break
                elif [ "$EXIT_CODE" = "5" ] && [ "$attempt" -lt 2 ]; then
                  echo "Network error, retrying (attempt $((attempt+2)))..."
                  sleep $((2 ** (attempt + 1)))
                  continue
                else
                  STATUS="fail"
                  break
                fi
              done

              RESULTS=$(echo "$RESULTS" | jq --arg r "$recipe_name" --arg p "$platform" \
                --arg s "$STATUS" --argjson e "$EXIT_CODE" --argjson a "$ATTEMPTS" \
                '. + [{"recipe": $r, "platform": $p, "status": $s, "exit_code": $e, "attempts": $a}]')
            done
          done

          echo "$RESULTS" > validation-results-linux-arm64.json
          echo "### Linux arm64 Validation Results" >> "$GITHUB_STEP_SUMMARY"
          echo '```json' >> "$GITHUB_STEP_SUMMARY"
          echo "$RESULTS" | jq . >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4
        with:
          name: validation-results-linux-arm64
          path: validation-results-linux-arm64.json
          retention-days: 1

  validate-darwin-arm64:
    needs: generate
    if: needs.generate.outputs.has_recipes == 'true'
    runs-on: macos-14
    timeout-minutes: 120
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        with:
          name: passing-recipes
          path: artifacts

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        with:
          name: tsuku-binaries

      - name: Make binary executable
        run: chmod +x tsuku-darwin-arm64

      - name: Install GNU coreutils for gtimeout
        run: brew install coreutils

      - name: Collect new recipe list
        id: recipes
        run: |
          RECIPE_LIST=""
          for f in artifacts/recipes/*/*.toml; do
            basename_path="${f#artifacts/}"
            if [ ! -f "$basename_path" ]; then
              RECIPE_LIST="$RECIPE_LIST $basename_path"
            fi
          done
          echo "list=$RECIPE_LIST" >> "$GITHUB_OUTPUT"

      - name: Copy new recipes into working tree
        run: cp -r artifacts/recipes/* recipes/

      - name: Validate on macOS arm64
        run: |
          RESULTS="[]"
          for recipe_path in ${{ steps.recipes.outputs.list }}; do
            recipe_name=$(basename "$recipe_path" .toml)

            case "$recipe_path" in
              *..*)
                echo "SKIP: path traversal detected in $recipe_path"
                continue
                ;;
            esac

            echo "--- $recipe_name on darwin-arm64 ---"
            STATUS="pass"
            EXIT_CODE=0
            ATTEMPTS=1

            for attempt in 0 1 2; do
              ATTEMPTS=$((attempt + 1))
              if gtimeout 300 ./tsuku-darwin-arm64 install --force --recipe "$recipe_path" 2>&1; then
                EXIT_CODE=0
                STATUS="pass"
                break
              else
                EXIT_CODE=$?
                if [ "$EXIT_CODE" = "5" ] && [ "$attempt" -lt 2 ]; then
                  echo "Network error, retrying (attempt $((attempt+2)))..."
                  sleep $((2 ** (attempt + 1)))
                  continue
                fi
                STATUS="fail"
                break
              fi
            done

            RESULTS=$(echo "$RESULTS" | jq --arg r "$recipe_name" --arg p "darwin-arm64" \
              --arg s "$STATUS" --argjson e "$EXIT_CODE" --argjson a "$ATTEMPTS" \
              '. + [{"recipe": $r, "platform": $p, "status": $s, "exit_code": $e, "attempts": $a}]')
          done

          echo "$RESULTS" > validation-results-darwin-arm64.json
          echo "### macOS arm64 Validation Results" >> "$GITHUB_STEP_SUMMARY"
          echo '```json' >> "$GITHUB_STEP_SUMMARY"
          echo "$RESULTS" | jq . >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4
        with:
          name: validation-results-darwin-arm64
          path: validation-results-darwin-arm64.json
          retention-days: 1

  validate-darwin-x86_64:
    needs: generate
    if: needs.generate.outputs.has_recipes == 'true'
    runs-on: macos-15-intel
    timeout-minutes: 120
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        with:
          name: passing-recipes
          path: artifacts

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        with:
          name: tsuku-binaries

      - name: Make binary executable
        run: chmod +x tsuku-darwin-amd64

      - name: Install GNU coreutils for gtimeout
        run: brew install coreutils

      - name: Collect new recipe list
        id: recipes
        run: |
          RECIPE_LIST=""
          for f in artifacts/recipes/*/*.toml; do
            basename_path="${f#artifacts/}"
            if [ ! -f "$basename_path" ]; then
              RECIPE_LIST="$RECIPE_LIST $basename_path"
            fi
          done
          echo "list=$RECIPE_LIST" >> "$GITHUB_OUTPUT"

      - name: Copy new recipes into working tree
        run: cp -r artifacts/recipes/* recipes/

      - name: Validate on macOS x86_64
        run: |
          RESULTS="[]"
          for recipe_path in ${{ steps.recipes.outputs.list }}; do
            recipe_name=$(basename "$recipe_path" .toml)

            case "$recipe_path" in
              *..*)
                echo "SKIP: path traversal detected in $recipe_path"
                continue
                ;;
            esac

            echo "--- $recipe_name on darwin-x86_64 ---"
            STATUS="pass"
            EXIT_CODE=0
            ATTEMPTS=1

            for attempt in 0 1 2; do
              ATTEMPTS=$((attempt + 1))
              if gtimeout 300 ./tsuku-darwin-amd64 install --force --recipe "$recipe_path" 2>&1; then
                EXIT_CODE=0
                STATUS="pass"
                break
              else
                EXIT_CODE=$?
                if [ "$EXIT_CODE" = "5" ] && [ "$attempt" -lt 2 ]; then
                  echo "Network error, retrying (attempt $((attempt+2)))..."
                  sleep $((2 ** (attempt + 1)))
                  continue
                fi
                STATUS="fail"
                break
              fi
            done

            RESULTS=$(echo "$RESULTS" | jq --arg r "$recipe_name" --arg p "darwin-x86_64" \
              --arg s "$STATUS" --argjson e "$EXIT_CODE" --argjson a "$ATTEMPTS" \
              '. + [{"recipe": $r, "platform": $p, "status": $s, "exit_code": $e, "attempts": $a}]')
          done

          echo "$RESULTS" > validation-results-darwin-x86_64.json
          echo "### macOS x86_64 Validation Results" >> "$GITHUB_STEP_SUMMARY"
          echo '```json' >> "$GITHUB_STEP_SUMMARY"
          echo "$RESULTS" | jq . >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4
        with:
          name: validation-results-darwin-x86_64
          path: validation-results-darwin-x86_64.json
          retention-days: 1

  merge:
    needs: [generate, validate-linux-x86_64, validate-linux-arm64, validate-darwin-arm64, validate-darwin-x86_64]
    if: always() && needs.generate.outputs.has_recipes == 'true' && needs.generate.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - uses: actions/setup-go@40f1582b2485089dde7abd97c1529aa768e1baff  # v5
        with:
          go-version-file: go.mod

      - name: Record merge start time
        run: echo "MERGE_START=$(date -u +%s)" >> "$GITHUB_ENV"

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        with:
          name: passing-recipes
          path: artifacts

      - name: Download validation results (tolerating missing artifacts)
        run: |
          # Download each result artifact, creating empty results for failed/skipped jobs
          for platform in linux-x86_64 linux-arm64 darwin-arm64 darwin-x86_64 linux-debian-glibc-x86_64; do
            echo "[]" > "validation-results-${platform}.json"
          done

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        continue-on-error: true
        with:
          name: validation-results-linux-x86_64

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        continue-on-error: true
        with:
          name: validation-results-linux-arm64

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        continue-on-error: true
        with:
          name: validation-results-darwin-arm64

      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        continue-on-error: true
        with:
          name: validation-results-darwin-x86_64

      # Generation-environment result from #1324 (may not exist yet)
      - uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        continue-on-error: true
        with:
          name: validation-results-linux-debian-glibc-x86_64

      - name: Copy new recipes into working tree
        run: cp -r artifacts/recipes/* recipes/

      - name: Copy data files
        run: |
          mkdir -p data
          if [ -d artifacts/data ]; then
            cp -r artifacts/data/* data/
          fi

      - name: Aggregate results and write constraints
        run: |
          # Merge all validation results
          jq -s 'add' \
            validation-results-linux-x86_64.json \
            validation-results-linux-arm64.json \
            validation-results-darwin-arm64.json \
            validation-results-darwin-x86_64.json \
            validation-results-linux-debian-glibc-x86_64.json \
            > all-results.json

          echo "### Aggregated Results" >> "$GITHUB_STEP_SUMMARY"

          # Get unique recipe names
          RECIPES=$(jq -r '.[].recipe' all-results.json | sort -u)

          # Track constraint info for PR body
          CONSTRAINT_LOG=""
          EXCLUDED_LOG=""
          INCLUDED_COUNT=0
          CONSTRAINED_COUNT=0
          EXCLUDED_COUNT=0
          INCLUDED_RECIPES=""
          EXCLUDED_RECIPES=""
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          FAILURE_JSONL="data/failures/${{ env.ECOSYSTEM }}.jsonl"
          mkdir -p "$(dirname "$FAILURE_JSONL")"

          for recipe in $RECIPES; do
            echo "=== Processing $recipe ==="

            # Check for run_command action (security gate)
            RECIPE_FILE=$(find recipes -name "${recipe}.toml" | head -1)
            if grep -q 'action.*=.*"run_command"' "$RECIPE_FILE" 2>/dev/null; then
              echo "EXCLUDE: $recipe has run_command action"
              rm -f "$RECIPE_FILE"
              EXCLUDED_LOG="${EXCLUDED_LOG}\n- **${recipe}**: contains run_command action (security gate)"
              EXCLUDED_COUNT=$((EXCLUDED_COUNT + 1))
              EXCLUDED_RECIPES="$EXCLUDED_RECIPES $recipe"
              continue
            fi

            # Count results by status (pass, fail, skipped)
            TOTAL=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r)] | length' all-results.json)
            PASSED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "pass")] | length' all-results.json)
            FAILED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "fail")] | length' all-results.json)
            SKIPPED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "skipped")] | length' all-results.json)

            echo "$recipe: $PASSED passed, $FAILED failed, $SKIPPED skipped (of $TOTAL)"

            # Write failure JSONL for each failed platform
            jq -c --arg r "$recipe" --arg ts "$TIMESTAMP" \
              '[.[] | select(.recipe == $r and .status == "fail")] | .[] |
              {
                schema_version: 1,
                recipe: .recipe,
                platform: .platform,
                exit_code: .exit_code,
                category: (if .exit_code == 5 then "network" elif .exit_code == 124 or .exit_code == 137 then "timeout" else "deterministic" end),
                timestamp: $ts
              }' all-results.json >> "$FAILURE_JSONL" 2>/dev/null || true

            # Effective results: pass + skipped count as "not failed"
            # A recipe with all skipped + pass should be included without constraints
            EFFECTIVE_PASSED=$((PASSED + SKIPPED))

            if [ "$EFFECTIVE_PASSED" = "$TOTAL" ]; then
              echo "All platforms pass or skipped, no constraints needed"
              INCLUDED_COUNT=$((INCLUDED_COUNT + 1))
              INCLUDED_RECIPES="$INCLUDED_RECIPES $recipe"
              continue
            fi

            if [ "$PASSED" = "0" ]; then
              echo "EXCLUDE: $recipe failed on all non-skipped platforms"
              rm -f "$RECIPE_FILE"
              EXCLUDED_LOG="${EXCLUDED_LOG}\n- **${recipe}**: failed on all platforms"
              EXCLUDED_COUNT=$((EXCLUDED_COUNT + 1))
              EXCLUDED_RECIPES="$EXCLUDED_RECIPES $recipe"
              continue
            fi

            # Derive constraints (only considers pass/fail, ignores skipped)
            ./scripts/write-platform-constraints.sh "$RECIPE_FILE" "$recipe" all-results.json
            CONSTRAINT=$(grep -E 'supported_os|supported_libc|unsupported_platforms' "$RECIPE_FILE" 2>/dev/null | head -1 || echo "unknown")
            CONSTRAINT_LOG="${CONSTRAINT_LOG}\n- **${recipe}**: ${CONSTRAINT}"
            CONSTRAINED_COUNT=$((CONSTRAINED_COUNT + 1))
            INCLUDED_COUNT=$((INCLUDED_COUNT + 1))
            INCLUDED_RECIPES="$INCLUDED_RECIPES $recipe"
          done

          # Summary table for step summary
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Recipe | Passed | Failed | Skipped | Constraints |" >> "$GITHUB_STEP_SUMMARY"
          echo "|--------|--------|--------|---------|-------------|" >> "$GITHUB_STEP_SUMMARY"
          for recipe in $RECIPES; do
            RECIPE_FILE=$(find recipes -name "${recipe}.toml" | head -1)
            if [ -z "$RECIPE_FILE" ]; then
              echo "| $recipe | - | - | - | Excluded |" >> "$GITHUB_STEP_SUMMARY"
              continue
            fi
            PASSED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "pass")] | length' all-results.json)
            FAILED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "fail")] | length' all-results.json)
            SKIPPED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "skipped")] | length' all-results.json)
            CONSTRAINTS=$(grep -E 'supported_os|supported_libc|unsupported_platforms' "$RECIPE_FILE" 2>/dev/null | head -1 || echo "None")
            echo "| $recipe | $PASSED | $FAILED | $SKIPPED | $CONSTRAINTS |" >> "$GITHUB_STEP_SUMMARY"
          done

          # Save counts for PR body step
          echo "INCLUDED_COUNT=$INCLUDED_COUNT" >> "$GITHUB_ENV"
          echo "CONSTRAINED_COUNT=$CONSTRAINED_COUNT" >> "$GITHUB_ENV"
          echo "EXCLUDED_COUNT=$EXCLUDED_COUNT" >> "$GITHUB_ENV"
          echo "INCLUDED_RECIPES=${INCLUDED_RECIPES# }" >> "$GITHUB_ENV"
          echo "EXCLUDED_RECIPES=${EXCLUDED_RECIPES# }" >> "$GITHUB_ENV"

          # Save logs for PR body (use files to avoid shell quoting issues)
          printf '%b' "$CONSTRAINT_LOG" > /tmp/constraint-log.md
          printf '%b' "$EXCLUDED_LOG" > /tmp/excluded-log.md

      - name: Generate batch ID
        run: |
          BATCH_DATE=$(date -u +%Y-%m-%d)
          BATCH_ID="${BATCH_DATE}-${{ env.ECOSYSTEM }}"

          # Check for existing same-day batches to add sequence number
          EXISTING=$(git log --oneline --all --grep="batch_id: ${BATCH_ID}" | wc -l)
          if [ "$EXISTING" -gt 0 ]; then
            SEQ=$((EXISTING + 1))
            BATCH_ID="${BATCH_ID}-$(printf '%03d' $SEQ)"
          fi

          echo "BATCH_ID=$BATCH_ID" >> "$GITHUB_ENV"
          echo "Generated batch ID: $BATCH_ID"

      - name: Update circuit breaker
        run: |
          if [ "$INCLUDED_COUNT" -gt 0 ]; then
            OUTCOME="success"
          else
            OUTCOME="failure"
          fi
          echo "Circuit breaker outcome: $OUTCOME"
          ./scripts/update_breaker.sh "${{ env.ECOSYSTEM }}" "$OUTCOME"

      - name: Requeue unblocked packages
        run: ./scripts/requeue-unblocked.sh

      - name: Collect SLI metrics
        run: |
          mkdir -p data/metrics
          DURATION=$(( $(date -u +%s) - MERGE_START ))
          TOTAL=$((INCLUDED_COUNT + EXCLUDED_COUNT))

          # Count generated recipes (those that made it to validation)
          GENERATED=$(jq 'length' all-results.json 2>/dev/null | head -1 || echo "0")
          # Deduplicate: count unique recipe names
          GENERATED=$(jq '[.[].recipe] | unique | length' all-results.json 2>/dev/null || echo "0")

          # Per-platform breakdown from validation result files
          PLATFORMS_JSON="{"
          for platform in linux-x86_64 linux-arm64 darwin-arm64 darwin-x86_64; do
            FILE="validation-results-${platform}.json"
            if [ -f "$FILE" ] && [ "$(jq 'length' "$FILE")" -gt 0 ]; then
              TESTED=$(jq 'length' "$FILE")
              PASSED=$(jq '[.[] | select(.status == "pass")] | length' "$FILE")
              FAILED=$(jq '[.[] | select(.status == "fail")] | length' "$FILE")
            else
              TESTED=0
              PASSED=0
              FAILED=0
            fi
            PLATFORMS_JSON="${PLATFORMS_JSON}\"${platform}\":{\"tested\":${TESTED},\"passed\":${PASSED},\"failed\":${FAILED}},"
          done
          # Remove trailing comma and close
          PLATFORMS_JSON="${PLATFORMS_JSON%,}}"

          jq -n \
            --arg batch_id "$BATCH_ID" \
            --arg ecosystem "${{ env.ECOSYSTEM }}" \
            --argjson total "$TOTAL" \
            --argjson generated "$GENERATED" \
            --argjson platforms "$PLATFORMS_JSON" \
            --argjson merged "$INCLUDED_COUNT" \
            --argjson excluded "$EXCLUDED_COUNT" \
            --argjson constrained "$CONSTRAINED_COUNT" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --argjson duration_seconds "$DURATION" \
            '{batch_id: $batch_id, ecosystem: $ecosystem, total: $total, generated: $generated, platforms: $platforms, merged: $merged, excluded: $excluded, constrained: $constrained, timestamp: $timestamp, duration_seconds: $duration_seconds}' \
            >> data/metrics/batch-runs.jsonl

          echo "SLI metrics appended for batch $BATCH_ID"

      - name: Generate dashboard
        run: |
          go build -o queue-analytics ./cmd/queue-analytics
          ./queue-analytics
          echo "Dashboard generated at website/pipeline/dashboard.json"

          # Write step summary if dashboard was generated
          DASHBOARD="website/pipeline/dashboard.json"
          if [ -f "$DASHBOARD" ]; then
            {
              echo "## Pipeline Queue Status"
              echo ""
              echo "| Status | Count |"
              echo "|--------|-------|"
              jq -r '.queue.by_status | to_entries[] | "| \(.key) | \(.value) |"' "$DASHBOARD"
              echo ""
              echo "**Total packages**: $(jq -r '.queue.total' "$DASHBOARD")"
              echo ""

              # Top 3 blockers (if any)
              BLOCKER_COUNT=$(jq '.blockers | length' "$DASHBOARD")
              if [ "$BLOCKER_COUNT" -gt 0 ]; then
                echo "### Top Blockers"
                echo ""
                echo "| Dependency | Blocked Packages |"
                echo "|------------|------------------|"
                jq -r '.blockers[:3][] | "| \(.dependency) | \(.count) |"' "$DASHBOARD"
                echo ""
              fi

              echo "[View full dashboard](https://tsuku.dev/pipeline/)"
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Check for recipes to merge
        id: check
        run: |
          if git diff --quiet recipes/ && [ -z "$(git ls-files --others --exclude-standard recipes/)" ]; then
            echo "changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "changes=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Persist circuit breaker and metrics state
        if: steps.check.outputs.changes == 'false'
        run: |
          git add batch-control.json data/metrics/ website/pipeline/dashboard.json 2>/dev/null || true
          if git diff --cached --quiet; then
            echo "No state changes to persist"
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git commit -m "chore(batch): update state for ${{ env.ECOSYSTEM }}"

          # Push with retry logic (3 attempts, exponential backoff)
          for attempt in 1 2 3; do
            if [ $attempt -gt 1 ]; then
              echo "::warning::Push attempt $attempt after failure"
              git pull --rebase origin main || { echo "::error::Rebase failed"; exit 1; }
              sleep $((2 ** attempt))
            fi
            if git push; then
              echo "Push succeeded on attempt $attempt"
              exit 0
            fi
          done
          echo "::error::Push failed after 3 attempts"
          exit 1
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Create pull request
        if: steps.check.outputs.changes == 'true'
        run: |
          # Update queue statuses for processed recipes
          for recipe in $INCLUDED_RECIPES; do
            jq --arg pkg "${{ env.ECOSYSTEM }}:${recipe}" \
              '(.packages[] | select(.id == $pkg)).status = "success"' \
              data/priority-queue.json > tmp.json && mv tmp.json data/priority-queue.json
          done
          for recipe in $EXCLUDED_RECIPES; do
            jq --arg pkg "${{ env.ECOSYSTEM }}:${recipe}" \
              '(.packages[] | select(.id == $pkg)).status = "failed"' \
              data/priority-queue.json > tmp.json && mv tmp.json data/priority-queue.json
          done

          BRANCH="batch/${{ env.ECOSYSTEM }}-$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BRANCH"
          git add recipes/ data/ batch-control.json website/pipeline/dashboard.json
          git reset HEAD -- data/batch-summary.md 2>/dev/null || true
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          TOTAL=$((INCLUDED_COUNT + EXCLUDED_COUNT))
          if [ "$TOTAL" -gt 0 ]; then
            SUCCESS_RATE=$(awk "BEGIN {printf \"%.2f\", $INCLUDED_COUNT / $TOTAL}")
          else
            SUCCESS_RATE="0.00"
          fi

          # Build structured commit message with git trailers
          {
            echo "feat(recipes): add batch ${BATCH_ID} recipes"
            echo ""
            echo "Batch generation of ${TOTAL} packages from ${{ env.ECOSYSTEM }} ecosystem."
            echo "- ${INCLUDED_COUNT} passed validation across platform environments"
            echo "- ${EXCLUDED_COUNT} excluded (recorded to data/failures/${{ env.ECOSYSTEM }}.jsonl)"
            echo ""
            echo "batch_id: ${BATCH_ID}"
            echo "ecosystem: ${{ env.ECOSYSTEM }}"
            echo "batch_size: ${TOTAL}"
            echo "success_rate: ${SUCCESS_RATE}"
          } > /tmp/commit-msg.txt

          git commit -F /tmp/commit-msg.txt
          git push -u origin "$BRANCH"

          # Build PR body with platform validation summary
          RECIPE_COUNT=$(git diff --name-only main -- recipes/ | wc -l)
          {
            echo "Batch ${{ env.ECOSYSTEM }} recipe generation: ${INCLUDED_COUNT} recipes included, ${EXCLUDED_COUNT} excluded."
            echo ""
            echo "Validated across 11 platform environments (5 Linux x86_64 families, 4 Linux arm64 families, 2 macOS)."
            if [ "$CONSTRAINED_COUNT" -gt 0 ]; then
              echo ""
              echo "## Platform Constraints"
              echo ""
              echo "${CONSTRAINED_COUNT} recipe(s) have partial platform coverage. Constraints were derived automatically:"
              cat /tmp/constraint-log.md 2>/dev/null || true
            fi
            if [ "$EXCLUDED_COUNT" -gt 0 ]; then
              echo ""
              echo "## Excluded Recipes"
              echo ""
              cat /tmp/excluded-log.md 2>/dev/null || true
            fi
            echo ""
            echo "---"
            echo ""
            echo "## Validation Summary"
            echo ""
            echo "| Platform | Status |"
            echo "|----------|--------|"
            for platform in linux-x86_64 linux-arm64 darwin-arm64 darwin-x86_64; do
              COUNT=$(jq "length" "validation-results-${platform}.json" 2>/dev/null || echo "0")
              if [ "$COUNT" = "0" ]; then
                echo "| ${platform} | No results (infrastructure failure or not yet implemented) |"
              else
                PASS=$(jq '[.[] | select(.status == "pass")] | length' "validation-results-${platform}.json")
                FAIL=$(jq '[.[] | select(.status == "fail")] | length' "validation-results-${platform}.json")
                echo "| ${platform} | ${PASS} passed, ${FAIL} failed |"
              fi
            done
          } > /tmp/pr-body.md

          PR_URL=$(gh pr create \
            --title "feat(recipes): add batch ${{ env.ECOSYSTEM }} recipes (${INCLUDED_COUNT} recipes)" \
            --body-file /tmp/pr-body.md \
            --base main)
          echo "PR_URL=$PR_URL" >> "$GITHUB_ENV"
          echo "Created PR: $PR_URL"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Enable auto-merge or post review notice
        if: steps.check.outputs.changes == 'true'
        run: |
          PR_NUMBER=$(echo "$PR_URL" | grep -o '[0-9]*$')
          if [ "$EXCLUDED_COUNT" -eq 0 ]; then
            echo "All recipes passed validation — enabling auto-merge"
            MERGE_ARGS=(--squash
              --subject "feat(recipes): add batch ${{ env.ECOSYSTEM }} recipes (${INCLUDED_COUNT} recipes)"
              --body "Batch generation of ${INCLUDED_COUNT} packages from ${{ env.ECOSYSTEM }} ecosystem. All recipes passed validation across platform environments.")
            if ! gh pr merge "$PR_NUMBER" --auto "${MERGE_ARGS[@]}" 2>&1; then
              echo "Auto-merge unavailable — waiting for CI checks to complete"
              if gh pr checks "$PR_NUMBER" --watch --fail-fast; then
                echo "All CI checks passed — merging"
                gh pr merge "$PR_NUMBER" "${MERGE_ARGS[@]}"
              else
                echo "::error::CI checks failed — not merging automatically"
                gh pr comment "$PR_NUMBER" --body "Auto-merge was skipped because CI checks failed. Please review the failures and merge manually after fixing."
                exit 1
              fi
            fi
          else
            echo "Some recipes were excluded — skipping auto-merge"
            gh pr comment "$PR_NUMBER" --body "Auto-merge was not enabled because ${EXCLUDED_COUNT} recipe(s) were excluded during validation. Please review the excluded recipes and merge manually."
          fi
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
