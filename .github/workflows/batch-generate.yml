name: Batch Recipe Generation
on:
  schedule:
    - cron: '0 * * * *'
  workflow_dispatch:
    inputs:
      ecosystem:
        description: 'Filter to specific ecosystem (optional, for debugging)'
        required: false
        type: choice
        options:
          - ''
          - homebrew
          - cargo
          - npm
          - pypi
          - rubygems
          - go
          - cpan
          - cask
      batch_size:
        description: 'Max recipes per run'
        required: true
        default: '25'
      tier:
        description: 'Queue tier (1=critical, 2=popular, 3=all)'
        required: true
        default: '3'
        type: choice
        options: ['1', '2', '3']

env:
  BATCH_SIZE: ${{ inputs.batch_size || '10' }}
  TIER: ${{ inputs.tier || '3' }}

concurrency:
  group: queue-operations
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write

jobs:
  generate:
    runs-on: ubuntu-latest
    outputs:
      has_recipes: ${{ steps.check.outputs.changes }}
      exit_code: ${{ steps.exit-code-default.outputs.exit_code }}
    steps:
      # Generate short-lived GitHub App token for PR creation and git operations.
      # Provides automatic rotation (60min expiry), scoped permissions, and audit trail.
      # Replaces long-lived PAT to reduce credential exposure risk.
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf  # v2
        with:
          app-id: ${{ secrets.TSUKU_BATCH_GENERATOR_APP_ID }}
          private-key: ${{ secrets.TSUKU_BATCH_GENERATOR_APP_PRIVATE_KEY }}

      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          token: ${{ steps.app-token.outputs.token }}

      - name: Check for open batch PRs
        id: check-open-prs
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          # Query for open PRs from batch branches (using search for prefix matching)
          OPEN_PRS=$(gh pr list --search "is:open head:batch/" --json number --jq 'length' 2>/dev/null || echo "0")

          if [ "$OPEN_PRS" -gt 0 ]; then
            echo "should_skip=true" >> "$GITHUB_OUTPUT"
            echo "::notice::Skipping batch run - $OPEN_PRS open batch PR(s) exist"
          else
            echo "should_skip=false" >> "$GITHUB_OUTPUT"
            echo "No open batch PRs - proceeding with batch generation"
          fi

      - uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5  # v6.2.0
        with:
          go-version-file: go.mod

      - name: Build binaries
        if: steps.check-open-prs.outputs.should_skip != 'true'
        run: |
          go build -o batch-generate ./cmd/batch-generate
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o tsuku-linux-amd64 ./cmd/tsuku
          CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -o tsuku-linux-arm64 ./cmd/tsuku
          CGO_ENABLED=0 GOOS=darwin GOARCH=arm64 go build -o tsuku-darwin-arm64 ./cmd/tsuku
          CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -o tsuku-darwin-amd64 ./cmd/tsuku
          cp tsuku-linux-amd64 tsuku
          echo "$PWD" >> "$GITHUB_PATH"

      - name: Run batch generation
        if: steps.check-open-prs.outputs.should_skip != 'true'
        id: batch
        run: |
          ARGS=(-batch-size "${{ env.BATCH_SIZE }}" -tier "${{ env.TIER }}")
          if [ -n "${{ inputs.ecosystem }}" ]; then
            ARGS+=(-filter-ecosystem "${{ inputs.ecosystem }}")
          fi
          set +e
          ./batch-generate "${ARGS[@]}"
          EXIT_CODE=$?
          set -e
          echo "exit_code=$EXIT_CODE" >> "$GITHUB_OUTPUT"
          exit $EXIT_CODE

      - name: Set default exit code if batch was skipped
        if: always()
        id: exit-code-default
        run: |
          # If batch step was skipped (open PRs exist), set exit code to 0
          # This ensures circuit breaker gets a valid exit code
          if [ -z "${{ steps.batch.outputs.exit_code }}" ]; then
            echo "exit_code=0" >> "$GITHUB_OUTPUT"
          else
            echo "exit_code=${{ steps.batch.outputs.exit_code }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Requeue unblocked packages
        if: steps.check-open-prs.outputs.should_skip != 'true'
        run: ./scripts/requeue-unblocked.sh

      - name: Check for generated recipes
        if: steps.check-open-prs.outputs.should_skip != 'true'
        id: check
        run: |
          if git diff --quiet && [ -z "$(git ls-files --others --exclude-standard recipes/)" ]; then
            echo "changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "changes=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Generate validation results for generation environment
        if: steps.check.outputs.changes == 'true'
        run: |
          # Create validation results for recipes that passed generation
          # These are all recipes that were successfully created and validated
          RESULTS="[]"

          # Find new/modified recipe files
          for recipe_path in $(git diff --name-only HEAD -- recipes/ && git ls-files --others --exclude-standard recipes/); do
            if [[ "$recipe_path" == *.toml ]]; then
              recipe_name=$(basename "$recipe_path" .toml)
              RESULTS=$(echo "$RESULTS" | jq --arg r "$recipe_name" \
                '. + [{"recipe": $r, "platform": "linux-debian-glibc-x86_64", "status": "pass", "exit_code": 0, "attempts": 1}]')
            fi
          done

          echo "$RESULTS" > validation-results-linux-debian-glibc-x86_64.json
          echo "Generated validation results for $(echo "$RESULTS" | jq length) recipes"
          cat validation-results-linux-debian-glibc-x86_64.json

      - name: Upload generation environment validation results
        if: steps.check.outputs.changes == 'true'
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: validation-results-linux-debian-glibc-x86_64
          path: validation-results-linux-debian-glibc-x86_64.json
          retention-days: 1

      - name: Upload passing recipes
        if: steps.check.outputs.changes == 'true'
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: passing-recipes
          path: |
            recipes/
            data/
          retention-days: 1

      - name: Upload tsuku binaries
        if: steps.check.outputs.changes == 'true'
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: tsuku-binaries
          path: |
            tsuku-linux-amd64
            tsuku-linux-arm64
            tsuku-darwin-arm64
            tsuku-darwin-amd64
          retention-days: 1

  validate-linux-x86_64:
    needs: generate
    if: needs.generate.outputs.has_recipes == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 120
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: passing-recipes
          path: artifacts

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: tsuku-binaries

      - name: Make binary executable
        run: chmod +x tsuku-linux-amd64

      - name: Collect new recipe list
        id: recipes
        run: |
          # Find recipes that were generated (in artifacts but not in checkout)
          shopt -s nullglob  # Empty glob expands to empty list, not literal pattern
          RECIPE_LIST=""
          for f in artifacts/recipes/*/*.toml; do
            basename_path="${f#artifacts/}"
            if [ ! -f "$basename_path" ]; then
              RECIPE_LIST="$RECIPE_LIST $basename_path"
            fi
          done
          echo "list=$RECIPE_LIST" >> "$GITHUB_OUTPUT"

      - name: Copy new recipes into working tree
        run: cp -r artifacts/recipes/* recipes/

      - name: Validate on all Linux x86_64 families
        run: |
          RESULTS_FILE=$(mktemp)
          IMAGES=("debian:bookworm-slim" "fedora:41" "archlinux:base" "opensuse/tumbleweed" "alpine:3.21")
          NAMES=("debian" "rhel" "arch" "suse" "alpine")
          LIBCS=("glibc" "glibc" "glibc" "glibc" "musl")

          # Load execution exclusions
          EXCLUSIONS=$(jq -r '.exclusions[].recipe' testdata/golden/execution-exclusions.json 2>/dev/null || echo "")

          for i in "${!IMAGES[@]}"; do
            image="${IMAGES[$i]}"
            family="${NAMES[$i]}"
            libc="${LIBCS[$i]}"
            platform="linux-${family}-${libc}-x86_64"

            echo "=== Validating on $platform ($image) ==="

            for recipe_path in ${{ steps.recipes.outputs.list }}; do
              recipe_name=$(basename "$recipe_path" .toml)

              case "$recipe_path" in
                *..*) echo "SKIP: path traversal in $recipe_path"; continue ;;
              esac

              # Check if recipe is in execution exclusions
              if echo "$EXCLUSIONS" | grep -qx "$recipe_name"; then
                echo "SKIP: $recipe_name is in execution-exclusions.json"
                echo '{"recipe":"'"$recipe_name"'","platform":"'"$platform"'","status":"skipped"}' >> "$RESULTS_FILE"
                continue
              fi

              echo "--- $recipe_name on $platform ---"
              STATUS="pass"
              EXIT_CODE=0
              ATTEMPTS=1

              BLOCKED_BY="[]"
              for attempt in 0 1 2; do
                ATTEMPTS=$((attempt + 1))
                # Write tsuku exit code and JSON output to files so Docker doesn't mask them
                docker run --rm \
                  -v "$PWD:/workspace" \
                  -w /workspace \
                  "$image" \
                  sh -c "
                    case '$family' in
                      alpine) apk add --no-cache curl bash ca-certificates jq ;;
                      debian) apt-get update && apt-get install -y --no-install-recommends curl ca-certificates jq ;;
                      rhel) dnf install -y --setopt=install_weak_deps=False curl ca-certificates jq ;;
                      arch) pacman -Sy --noconfirm curl ca-certificates jq ;;
                      suse) zypper -n install curl ca-certificates jq ;;
                    esac
                    timeout 300 ./tsuku-linux-amd64 install --json --force --recipe '$recipe_path' > /workspace/.tsuku-output.json 2>&1
                    echo \$? > /workspace/.tsuku-exit-code
                  " 2>&1 || true

                if [ -f .tsuku-exit-code ]; then
                  EXIT_CODE=$(cat .tsuku-exit-code)
                  rm -f .tsuku-exit-code
                else
                  # Container failed before running tsuku (Docker error)
                  EXIT_CODE=1
                fi

                # Extract blocked_by from JSON output if exit code is 8 (missing_dep)
                if [ -f .tsuku-output.json ]; then
                  cat .tsuku-output.json  # Show output for logging
                  if [ "$EXIT_CODE" = "8" ]; then
                    BLOCKED_BY=$(jq -c '.missing_recipes // []' .tsuku-output.json 2>/dev/null || echo "[]")
                  fi
                  rm -f .tsuku-output.json
                fi

                if [ "$EXIT_CODE" = "0" ]; then
                  STATUS="pass"
                  break
                elif [ "$EXIT_CODE" = "5" ] && [ "$attempt" -lt 2 ]; then
                  echo "Network error, retrying (attempt $((attempt+2)))..."
                  sleep $((2 ** (attempt + 1)))
                  continue
                else
                  STATUS="fail"
                  break
                fi
              done

              echo '{"recipe":"'"$recipe_name"'","platform":"'"$platform"'","status":"'"$STATUS"'","exit_code":'"$EXIT_CODE"',"attempts":'"$ATTEMPTS"',"blocked_by":'"$BLOCKED_BY"'}' >> "$RESULTS_FILE"
            done
          done

          # Convert NDJSON to JSON array
          if [ -s "$RESULTS_FILE" ]; then
            jq -s '.' "$RESULTS_FILE" > validation-results-linux-x86_64.json
          else
            echo '[]' > validation-results-linux-x86_64.json
          fi
          RESULTS=$(cat validation-results-linux-x86_64.json)
          rm -f "$RESULTS_FILE"

          # Summary with counts
          TOTAL=$(echo "$RESULTS" | jq length)
          PASSED=$(echo "$RESULTS" | jq '[.[] | select(.status == "pass")] | length')
          FAILED=$(echo "$RESULTS" | jq '[.[] | select(.status == "fail")] | length')
          SKIPPED=$(echo "$RESULTS" | jq '[.[] | select(.status == "skipped")] | length')

          echo "### Linux x86_64 Validation Results" >> "$GITHUB_STEP_SUMMARY"
          echo "- Total: $TOTAL" >> "$GITHUB_STEP_SUMMARY"
          echo "- Passed: $PASSED" >> "$GITHUB_STEP_SUMMARY"
          echo "- Failed: $FAILED" >> "$GITHUB_STEP_SUMMARY"
          echo "- Skipped: $SKIPPED" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo '```json' >> "$GITHUB_STEP_SUMMARY"
          echo "$RESULTS" | jq . >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: validation-results-linux-x86_64
          path: validation-results-linux-x86_64.json
          retention-days: 1

  validate-linux-arm64:
    needs: generate
    if: needs.generate.outputs.has_recipes == 'true'
    runs-on: ubuntu-24.04-arm
    timeout-minutes: 120
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: passing-recipes
          path: artifacts

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: tsuku-binaries

      - name: Make binary executable
        run: chmod +x tsuku-linux-arm64

      - name: Collect new recipe list
        id: recipes
        run: |
          shopt -s nullglob  # Empty glob expands to empty list, not literal pattern
          RECIPE_LIST=""
          for f in artifacts/recipes/*/*.toml; do
            basename_path="${f#artifacts/}"
            if [ ! -f "$basename_path" ]; then
              RECIPE_LIST="$RECIPE_LIST $basename_path"
            fi
          done
          echo "list=$RECIPE_LIST" >> "$GITHUB_OUTPUT"

      - name: Copy new recipes into working tree
        run: cp -r artifacts/recipes/* recipes/

      - name: Validate on all Linux arm64 families
        run: |
          RESULTS_FILE=$(mktemp)
          # archlinux:base excluded -- no ARM64 container image
          IMAGES=("debian:bookworm-slim" "fedora:41" "opensuse/tumbleweed" "alpine:3.21")
          NAMES=("debian" "rhel" "suse" "alpine")
          LIBCS=("glibc" "glibc" "glibc" "musl")

          # Load execution exclusions
          EXCLUSIONS=$(jq -r '.exclusions[].recipe' testdata/golden/execution-exclusions.json 2>/dev/null || echo "")

          for i in "${!IMAGES[@]}"; do
            image="${IMAGES[$i]}"
            family="${NAMES[$i]}"
            libc="${LIBCS[$i]}"
            platform="linux-${family}-${libc}-arm64"

            echo "=== Validating on $platform ($image) ==="

            for recipe_path in ${{ steps.recipes.outputs.list }}; do
              recipe_name=$(basename "$recipe_path" .toml)

              case "$recipe_path" in
                *..*) echo "SKIP: path traversal in $recipe_path"; continue ;;
              esac

              # Check if recipe is in execution exclusions
              if echo "$EXCLUSIONS" | grep -qx "$recipe_name"; then
                echo "SKIP: $recipe_name is in execution-exclusions.json"
                echo '{"recipe":"'"$recipe_name"'","platform":"'"$platform"'","status":"skipped"}' >> "$RESULTS_FILE"
                continue
              fi

              echo "--- $recipe_name on $platform ---"
              STATUS="pass"
              EXIT_CODE=0
              ATTEMPTS=1

              BLOCKED_BY="[]"
              for attempt in 0 1 2; do
                ATTEMPTS=$((attempt + 1))
                docker run --rm \
                  -v "$PWD:/workspace" \
                  -w /workspace \
                  "$image" \
                  sh -c "
                    case '$family' in
                      alpine) apk add --no-cache curl bash ca-certificates jq ;;
                      debian) apt-get update && apt-get install -y --no-install-recommends curl ca-certificates jq ;;
                      rhel) dnf install -y --setopt=install_weak_deps=False curl ca-certificates jq ;;
                      suse) zypper -n install curl ca-certificates jq ;;
                    esac
                    timeout 300 ./tsuku-linux-arm64 install --json --force --recipe '$recipe_path' > /workspace/.tsuku-output.json 2>&1
                    echo \$? > /workspace/.tsuku-exit-code
                  " 2>&1 || true

                if [ -f .tsuku-exit-code ]; then
                  EXIT_CODE=$(cat .tsuku-exit-code)
                  rm -f .tsuku-exit-code
                else
                  EXIT_CODE=1
                fi

                # Extract blocked_by from JSON output if exit code is 8 (missing_dep)
                if [ -f .tsuku-output.json ]; then
                  cat .tsuku-output.json  # Show output for logging
                  if [ "$EXIT_CODE" = "8" ]; then
                    BLOCKED_BY=$(jq -c '.missing_recipes // []' .tsuku-output.json 2>/dev/null || echo "[]")
                  fi
                  rm -f .tsuku-output.json
                fi

                if [ "$EXIT_CODE" = "0" ]; then
                  STATUS="pass"
                  break
                elif [ "$EXIT_CODE" = "5" ] && [ "$attempt" -lt 2 ]; then
                  echo "Network error, retrying (attempt $((attempt+2)))..."
                  sleep $((2 ** (attempt + 1)))
                  continue
                else
                  STATUS="fail"
                  break
                fi
              done

              echo '{"recipe":"'"$recipe_name"'","platform":"'"$platform"'","status":"'"$STATUS"'","exit_code":'"$EXIT_CODE"',"attempts":'"$ATTEMPTS"',"blocked_by":'"$BLOCKED_BY"'}' >> "$RESULTS_FILE"
            done
          done

          # Convert NDJSON to JSON array
          if [ -s "$RESULTS_FILE" ]; then
            jq -s '.' "$RESULTS_FILE" > validation-results-linux-arm64.json
          else
            echo '[]' > validation-results-linux-arm64.json
          fi
          RESULTS=$(cat validation-results-linux-arm64.json)
          rm -f "$RESULTS_FILE"

          # Summary with counts
          TOTAL=$(echo "$RESULTS" | jq length)
          PASSED=$(echo "$RESULTS" | jq '[.[] | select(.status == "pass")] | length')
          FAILED=$(echo "$RESULTS" | jq '[.[] | select(.status == "fail")] | length')
          SKIPPED=$(echo "$RESULTS" | jq '[.[] | select(.status == "skipped")] | length')

          echo "### Linux arm64 Validation Results" >> "$GITHUB_STEP_SUMMARY"
          echo "- Total: $TOTAL" >> "$GITHUB_STEP_SUMMARY"
          echo "- Passed: $PASSED" >> "$GITHUB_STEP_SUMMARY"
          echo "- Failed: $FAILED" >> "$GITHUB_STEP_SUMMARY"
          echo "- Skipped: $SKIPPED" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo '```json' >> "$GITHUB_STEP_SUMMARY"
          echo "$RESULTS" | jq . >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: validation-results-linux-arm64
          path: validation-results-linux-arm64.json
          retention-days: 1

  validate-darwin-arm64:
    needs: generate
    if: needs.generate.outputs.has_recipes == 'true'
    runs-on: macos-14
    timeout-minutes: 120
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: passing-recipes
          path: artifacts

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: tsuku-binaries

      - name: Make binary executable
        run: chmod +x tsuku-darwin-arm64

      - name: Install GNU coreutils for gtimeout
        run: brew install coreutils

      - name: Collect new recipe list
        id: recipes
        run: |
          shopt -s nullglob  # Empty glob expands to empty list, not literal pattern
          RECIPE_LIST=""
          for f in artifacts/recipes/*/*.toml; do
            basename_path="${f#artifacts/}"
            if [ ! -f "$basename_path" ]; then
              RECIPE_LIST="$RECIPE_LIST $basename_path"
            fi
          done
          echo "list=$RECIPE_LIST" >> "$GITHUB_OUTPUT"

      - name: Copy new recipes into working tree
        run: cp -r artifacts/recipes/* recipes/

      - name: Validate on macOS arm64
        run: |
          # Use NDJSON accumulation for O(n) performance
          RESULTS_FILE=$(mktemp)

          # Load execution exclusions
          EXCLUSIONS=$(jq -r '.exclusions[].recipe' testdata/golden/execution-exclusions.json 2>/dev/null || echo "")

          for recipe_path in ${{ steps.recipes.outputs.list }}; do
            recipe_name=$(basename "$recipe_path" .toml)

            case "$recipe_path" in
              *..*)
                echo "SKIP: path traversal detected in $recipe_path"
                continue
                ;;
            esac

            # Check if recipe is in execution exclusions
            if echo "$EXCLUSIONS" | grep -qx "$recipe_name"; then
              echo "SKIP: $recipe_name is in execution-exclusions.json"
              echo '{"recipe":"'"$recipe_name"'","platform":"darwin-arm64","status":"skipped"}' >> "$RESULTS_FILE"
              continue
            fi

            echo "--- $recipe_name on darwin-arm64 ---"
            STATUS="pass"
            EXIT_CODE=0
            ATTEMPTS=1
            BLOCKED_BY="[]"

            for attempt in 0 1 2; do
              ATTEMPTS=$((attempt + 1))
              if gtimeout 300 ./tsuku-darwin-arm64 install --json --force --recipe "$recipe_path" > .tsuku-output.json 2>&1; then
                EXIT_CODE=0
                STATUS="pass"
                cat .tsuku-output.json  # Show output for logging
                rm -f .tsuku-output.json
                break
              else
                EXIT_CODE=$?
                cat .tsuku-output.json 2>/dev/null || true  # Show output for logging
                # Extract blocked_by from JSON output if exit code is 8 (missing_dep)
                if [ "$EXIT_CODE" = "8" ] && [ -f .tsuku-output.json ]; then
                  BLOCKED_BY=$(jq -c '.missing_recipes // []' .tsuku-output.json 2>/dev/null || echo "[]")
                fi
                rm -f .tsuku-output.json
                if [ "$EXIT_CODE" = "5" ] && [ "$attempt" -lt 2 ]; then
                  echo "Network error, retrying (attempt $((attempt+2)))..."
                  sleep $((2 ** (attempt + 1)))
                  continue
                fi
                STATUS="fail"
                break
              fi
            done

            echo '{"recipe":"'"$recipe_name"'","platform":"darwin-arm64","status":"'"$STATUS"'","exit_code":'"$EXIT_CODE"',"attempts":'"$ATTEMPTS"',"blocked_by":'"$BLOCKED_BY"'}' >> "$RESULTS_FILE"
          done

          # Convert NDJSON to JSON array
          if [ -s "$RESULTS_FILE" ]; then
            jq -s '.' "$RESULTS_FILE" > validation-results-darwin-arm64.json
          else
            echo '[]' > validation-results-darwin-arm64.json
          fi
          RESULTS=$(cat validation-results-darwin-arm64.json)
          rm -f "$RESULTS_FILE"

          # Summary with counts
          TOTAL=$(echo "$RESULTS" | jq length)
          PASSED=$(echo "$RESULTS" | jq '[.[] | select(.status == "pass")] | length')
          FAILED=$(echo "$RESULTS" | jq '[.[] | select(.status == "fail")] | length')
          SKIPPED=$(echo "$RESULTS" | jq '[.[] | select(.status == "skipped")] | length')

          echo "### macOS arm64 Validation Results" >> "$GITHUB_STEP_SUMMARY"
          echo "- Total: $TOTAL" >> "$GITHUB_STEP_SUMMARY"
          echo "- Passed: $PASSED" >> "$GITHUB_STEP_SUMMARY"
          echo "- Failed: $FAILED" >> "$GITHUB_STEP_SUMMARY"
          echo "- Skipped: $SKIPPED" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo '```json' >> "$GITHUB_STEP_SUMMARY"
          echo "$RESULTS" | jq . >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: validation-results-darwin-arm64
          path: validation-results-darwin-arm64.json
          retention-days: 1

  validate-darwin-x86_64:
    needs: generate
    if: needs.generate.outputs.has_recipes == 'true'
    runs-on: macos-15-intel
    timeout-minutes: 120
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: passing-recipes
          path: artifacts

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: tsuku-binaries

      - name: Make binary executable
        run: chmod +x tsuku-darwin-amd64

      - name: Install GNU coreutils for gtimeout
        run: brew install coreutils

      - name: Collect new recipe list
        id: recipes
        run: |
          shopt -s nullglob  # Empty glob expands to empty list, not literal pattern
          RECIPE_LIST=""
          for f in artifacts/recipes/*/*.toml; do
            basename_path="${f#artifacts/}"
            if [ ! -f "$basename_path" ]; then
              RECIPE_LIST="$RECIPE_LIST $basename_path"
            fi
          done
          echo "list=$RECIPE_LIST" >> "$GITHUB_OUTPUT"

      - name: Copy new recipes into working tree
        run: cp -r artifacts/recipes/* recipes/

      - name: Validate on macOS x86_64
        run: |
          # Use NDJSON accumulation for O(n) performance
          RESULTS_FILE=$(mktemp)

          # Load execution exclusions
          EXCLUSIONS=$(jq -r '.exclusions[].recipe' testdata/golden/execution-exclusions.json 2>/dev/null || echo "")

          for recipe_path in ${{ steps.recipes.outputs.list }}; do
            recipe_name=$(basename "$recipe_path" .toml)

            case "$recipe_path" in
              *..*)
                echo "SKIP: path traversal detected in $recipe_path"
                continue
                ;;
            esac

            # Check if recipe is in execution exclusions
            if echo "$EXCLUSIONS" | grep -qx "$recipe_name"; then
              echo "SKIP: $recipe_name is in execution-exclusions.json"
              echo '{"recipe":"'"$recipe_name"'","platform":"darwin-x86_64","status":"skipped"}' >> "$RESULTS_FILE"
              continue
            fi

            echo "--- $recipe_name on darwin-x86_64 ---"
            STATUS="pass"
            EXIT_CODE=0
            ATTEMPTS=1
            BLOCKED_BY="[]"

            for attempt in 0 1 2; do
              ATTEMPTS=$((attempt + 1))
              if gtimeout 300 ./tsuku-darwin-amd64 install --json --force --recipe "$recipe_path" > .tsuku-output.json 2>&1; then
                EXIT_CODE=0
                STATUS="pass"
                cat .tsuku-output.json  # Show output for logging
                rm -f .tsuku-output.json
                break
              else
                EXIT_CODE=$?
                cat .tsuku-output.json 2>/dev/null || true  # Show output for logging
                # Extract blocked_by from JSON output if exit code is 8 (missing_dep)
                if [ "$EXIT_CODE" = "8" ] && [ -f .tsuku-output.json ]; then
                  BLOCKED_BY=$(jq -c '.missing_recipes // []' .tsuku-output.json 2>/dev/null || echo "[]")
                fi
                rm -f .tsuku-output.json
                if [ "$EXIT_CODE" = "5" ] && [ "$attempt" -lt 2 ]; then
                  echo "Network error, retrying (attempt $((attempt+2)))..."
                  sleep $((2 ** (attempt + 1)))
                  continue
                fi
                STATUS="fail"
                break
              fi
            done

            echo '{"recipe":"'"$recipe_name"'","platform":"darwin-x86_64","status":"'"$STATUS"'","exit_code":'"$EXIT_CODE"',"attempts":'"$ATTEMPTS"',"blocked_by":'"$BLOCKED_BY"'}' >> "$RESULTS_FILE"
          done

          # Convert NDJSON to JSON array
          if [ -s "$RESULTS_FILE" ]; then
            jq -s '.' "$RESULTS_FILE" > validation-results-darwin-x86_64.json
          else
            echo '[]' > validation-results-darwin-x86_64.json
          fi
          RESULTS=$(cat validation-results-darwin-x86_64.json)
          rm -f "$RESULTS_FILE"

          # Summary with counts
          TOTAL=$(echo "$RESULTS" | jq length)
          PASSED=$(echo "$RESULTS" | jq '[.[] | select(.status == "pass")] | length')
          FAILED=$(echo "$RESULTS" | jq '[.[] | select(.status == "fail")] | length')
          SKIPPED=$(echo "$RESULTS" | jq '[.[] | select(.status == "skipped")] | length')

          echo "### macOS x86_64 Validation Results" >> "$GITHUB_STEP_SUMMARY"
          echo "- Total: $TOTAL" >> "$GITHUB_STEP_SUMMARY"
          echo "- Passed: $PASSED" >> "$GITHUB_STEP_SUMMARY"
          echo "- Failed: $FAILED" >> "$GITHUB_STEP_SUMMARY"
          echo "- Skipped: $SKIPPED" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo '```json' >> "$GITHUB_STEP_SUMMARY"
          echo "$RESULTS" | jq . >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: validation-results-darwin-x86_64
          path: validation-results-darwin-x86_64.json
          retention-days: 1

  merge:
    needs: [generate, validate-linux-x86_64, validate-linux-arm64, validate-darwin-arm64, validate-darwin-x86_64]
    if: always() && needs.generate.outputs.has_recipes == 'true' && needs.generate.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf  # v2
        with:
          app-id: ${{ secrets.TSUKU_BATCH_GENERATOR_APP_ID }}
          private-key: ${{ secrets.TSUKU_BATCH_GENERATOR_APP_PRIVATE_KEY }}

      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          token: ${{ steps.app-token.outputs.token }}

      - uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5  # v6.2.0
        with:
          go-version-file: go.mod

      - name: Record merge start time
        run: echo "MERGE_START=$(date -u +%s)" >> "$GITHUB_ENV"

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: passing-recipes
          path: artifacts

      - name: Download validation results (tolerating missing artifacts)
        run: |
          # Download each result artifact, creating empty results for failed/skipped jobs
          for platform in linux-x86_64 linux-arm64 darwin-arm64 darwin-x86_64 linux-debian-glibc-x86_64; do
            echo "[]" > "validation-results-${platform}.json"
          done

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        continue-on-error: true
        with:
          name: validation-results-linux-x86_64

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        continue-on-error: true
        with:
          name: validation-results-linux-arm64

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        continue-on-error: true
        with:
          name: validation-results-darwin-arm64

      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        continue-on-error: true
        with:
          name: validation-results-darwin-x86_64

      # Generation-environment result (produced by generate job)
      - uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        continue-on-error: true
        with:
          name: validation-results-linux-debian-glibc-x86_64

      - name: Copy new recipes into working tree
        run: cp -r artifacts/recipes/* recipes/

      - name: Copy data files
        run: |
          mkdir -p data
          if [ -d artifacts/data ]; then
            cp -r artifacts/data/* data/
          fi

      - name: Aggregate results and write constraints
        run: |
          # Merge all validation results
          jq -s 'add' \
            validation-results-linux-x86_64.json \
            validation-results-linux-arm64.json \
            validation-results-darwin-arm64.json \
            validation-results-darwin-x86_64.json \
            validation-results-linux-debian-glibc-x86_64.json \
            > all-results.json

          echo "### Aggregated Results" >> "$GITHUB_STEP_SUMMARY"

          # Get unique recipe names
          RECIPES=$(jq -r '.[].recipe' all-results.json | sort -u)

          # Track constraint info for PR body
          CONSTRAINT_LOG=""
          EXCLUDED_LOG=""
          INCLUDED_COUNT=0
          CONSTRAINED_COUNT=0
          EXCLUDED_COUNT=0
          INCLUDED_RECIPES=""
          EXCLUDED_RECIPES=""
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          # Use timestamp in filename (with hyphens instead of colons for artifact compatibility)
          TIMESTAMP_SAFE=$(echo "$TIMESTAMP" | tr ':' '-')
          FAILURE_JSONL="data/failures/batch-${TIMESTAMP_SAFE}.jsonl"
          mkdir -p "$(dirname "$FAILURE_JSONL")"

          for recipe in $RECIPES; do
            echo "=== Processing $recipe ==="

            # Check for run_command action (security gate)
            RECIPE_FILE=$(find recipes -name "${recipe}.toml" | head -1)
            if grep -q 'action.*=.*"run_command"' "$RECIPE_FILE" 2>/dev/null; then
              echo "EXCLUDE: $recipe has run_command action"
              rm -f "$RECIPE_FILE"
              EXCLUDED_LOG="${EXCLUDED_LOG}\n- **${recipe}**: contains run_command action (security gate)"
              EXCLUDED_COUNT=$((EXCLUDED_COUNT + 1))
              EXCLUDED_RECIPES="$EXCLUDED_RECIPES $recipe"
              continue
            fi

            # Count results by status (pass, fail, skipped)
            TOTAL=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r)] | length' all-results.json)
            PASSED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "pass")] | length' all-results.json)
            FAILED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "fail")] | length' all-results.json)
            SKIPPED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "skipped")] | length' all-results.json)

            echo "$recipe: $PASSED passed, $FAILED failed, $SKIPPED skipped (of $TOTAL)"

            # Write failure JSONL for each failed platform
            jq -c --arg r "$recipe" --arg ts "$TIMESTAMP" \
              '[.[] | select(.recipe == $r and .status == "fail")] | .[] |
              {
                schema_version: 1,
                recipe: .recipe,
                platform: .platform,
                exit_code: .exit_code,
                category: (if .exit_code == 8 then "missing_dep" elif .exit_code == 5 or .exit_code == 124 or .exit_code == 137 then "network_error" else "generation_failed" end),
                blocked_by: (if .exit_code == 8 and (.blocked_by | length) > 0 then .blocked_by else null end),
                timestamp: $ts
              } | with_entries(select(.value != null))' all-results.json >> "$FAILURE_JSONL" 2>/dev/null || true

            # Effective results: pass + skipped count as "not failed"
            # A recipe with all skipped + pass should be included without constraints
            EFFECTIVE_PASSED=$((PASSED + SKIPPED))

            if [ "$EFFECTIVE_PASSED" = "$TOTAL" ]; then
              echo "All platforms pass or skipped, no constraints needed"
              INCLUDED_COUNT=$((INCLUDED_COUNT + 1))
              INCLUDED_RECIPES="$INCLUDED_RECIPES $recipe"
              continue
            fi

            if [ "$PASSED" = "0" ]; then
              echo "EXCLUDE: $recipe failed on all non-skipped platforms"
              rm -f "$RECIPE_FILE"
              EXCLUDED_LOG="${EXCLUDED_LOG}\n- **${recipe}**: failed on all platforms"
              EXCLUDED_COUNT=$((EXCLUDED_COUNT + 1))
              EXCLUDED_RECIPES="$EXCLUDED_RECIPES $recipe"
              continue
            fi

            # Derive constraints (only considers pass/fail, ignores skipped)
            ./scripts/write-platform-constraints.sh "$RECIPE_FILE" "$recipe" all-results.json
            CONSTRAINT=$(grep -E 'supported_os|supported_libc|unsupported_platforms' "$RECIPE_FILE" 2>/dev/null | head -1 || echo "unknown")
            CONSTRAINT_LOG="${CONSTRAINT_LOG}\n- **${recipe}**: ${CONSTRAINT}"
            CONSTRAINED_COUNT=$((CONSTRAINED_COUNT + 1))
            INCLUDED_COUNT=$((INCLUDED_COUNT + 1))
            INCLUDED_RECIPES="$INCLUDED_RECIPES $recipe"
          done

          # Summary table for step summary
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Recipe | Passed | Failed | Skipped | Constraints |" >> "$GITHUB_STEP_SUMMARY"
          echo "|--------|--------|--------|---------|-------------|" >> "$GITHUB_STEP_SUMMARY"
          for recipe in $RECIPES; do
            RECIPE_FILE=$(find recipes -name "${recipe}.toml" | head -1)
            if [ -z "$RECIPE_FILE" ]; then
              echo "| $recipe | - | - | - | Excluded |" >> "$GITHUB_STEP_SUMMARY"
              continue
            fi
            PASSED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "pass")] | length' all-results.json)
            FAILED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "fail")] | length' all-results.json)
            SKIPPED=$(jq --arg r "$recipe" '[.[] | select(.recipe == $r and .status == "skipped")] | length' all-results.json)
            CONSTRAINTS=$(grep -E 'supported_os|supported_libc|unsupported_platforms' "$RECIPE_FILE" 2>/dev/null | head -1 || echo "None")
            echo "| $recipe | $PASSED | $FAILED | $SKIPPED | $CONSTRAINTS |" >> "$GITHUB_STEP_SUMMARY"
          done

          # Save counts for PR body step
          echo "INCLUDED_COUNT=$INCLUDED_COUNT" >> "$GITHUB_ENV"
          echo "CONSTRAINED_COUNT=$CONSTRAINED_COUNT" >> "$GITHUB_ENV"
          echo "EXCLUDED_COUNT=$EXCLUDED_COUNT" >> "$GITHUB_ENV"
          echo "INCLUDED_RECIPES=${INCLUDED_RECIPES# }" >> "$GITHUB_ENV"
          echo "EXCLUDED_RECIPES=${EXCLUDED_RECIPES# }" >> "$GITHUB_ENV"

          # Save logs for PR body (use files to avoid shell quoting issues)
          printf '%b' "$CONSTRAINT_LOG" > /tmp/constraint-log.md
          printf '%b' "$EXCLUDED_LOG" > /tmp/excluded-log.md

      - name: Generate batch ID
        run: |
          BATCH_DATE=$(date -u +%Y-%m-%d)
          BATCH_ID="${BATCH_DATE}"

          # Check for existing same-day batches to add sequence number
          EXISTING=$(git log --oneline --all --grep="batch_id: ${BATCH_ID}" | wc -l)
          if [ "$EXISTING" -gt 0 ]; then
            SEQ=$((EXISTING + 1))
            BATCH_ID="${BATCH_ID}-$(printf '%03d' $SEQ)"
          fi

          echo "BATCH_ID=$BATCH_ID" >> "$GITHUB_ENV"
          echo "Generated batch ID: $BATCH_ID"

      - name: Update circuit breaker
        run: |
          # Read per-ecosystem outcomes from batch-results.json written by the orchestrator.
          # Each ecosystem that participated in the batch gets its breaker updated.
          RESULTS_FILE="data/queues/batch-results.json"
          if [ ! -f "$RESULTS_FILE" ] || [ ! -s "$RESULTS_FILE" ]; then
            echo "No batch results file found, skipping circuit breaker update"
            exit 0
          fi

          # Transition open breakers to half-open before updating outcomes.
          # The generate job does this on its runner, but the merge job has a
          # fresh checkout so the file still says "open". check_breaker.sh
          # transitions open -> half-open when opens_at has passed, which lets
          # update_breaker.sh correctly handle the half-open + failure -> open
          # (with fresh timeout) transition.
          for eco in $(jq -r '.per_ecosystem | keys[]' "$RESULTS_FILE" 2>/dev/null); do
            ./scripts/check_breaker.sh "$eco"
          done

          # Iterate over each ecosystem in per_ecosystem breakdown
          for eco in $(jq -r '.per_ecosystem | keys[]' "$RESULTS_FILE" 2>/dev/null); do
            FAILED=$(jq -r --arg e "$eco" '.per_ecosystem[$e].failed // 0' "$RESULTS_FILE")
            SUCCEEDED=$(jq -r --arg e "$eco" '.per_ecosystem[$e].succeeded // 0' "$RESULTS_FILE")

            if [ "$FAILED" -gt 0 ] && [ "$SUCCEEDED" -eq 0 ]; then
              OUTCOME="failure"
              echo "::warning::Circuit breaker: all $eco entries failed ($FAILED failures)"
            else
              OUTCOME="success"
              echo "Circuit breaker: $eco had $SUCCEEDED succeeded, $FAILED failed"
            fi
            ./scripts/update_breaker.sh "$eco" "$OUTCOME"
          done

      - name: Requeue unblocked packages
        run: ./scripts/requeue-unblocked.sh

      - name: Collect SLI metrics
        run: |
          mkdir -p data/metrics
          DURATION=$(( $(date -u +%s) - MERGE_START ))
          TOTAL=$((INCLUDED_COUNT + EXCLUDED_COUNT))

          # Count generated recipes (those that made it to validation)
          GENERATED=$(jq 'length' all-results.json 2>/dev/null | head -1 || echo "0")
          # Deduplicate: count unique recipe names
          GENERATED=$(jq '[.[].recipe] | unique | length' all-results.json 2>/dev/null || echo "0")

          # Per-platform breakdown from validation result files
          PLATFORMS_JSON="{"
          for platform in linux-x86_64 linux-arm64 darwin-arm64 darwin-x86_64; do
            FILE="validation-results-${platform}.json"
            if [ -f "$FILE" ] && [ "$(jq 'length' "$FILE")" -gt 0 ]; then
              TESTED=$(jq 'length' "$FILE")
              PASSED=$(jq '[.[] | select(.status == "pass")] | length' "$FILE")
              FAILED=$(jq '[.[] | select(.status == "fail")] | length' "$FILE")
            else
              TESTED=0
              PASSED=0
              FAILED=0
            fi
            PLATFORMS_JSON="${PLATFORMS_JSON}\"${platform}\":{\"tested\":${TESTED},\"passed\":${PASSED},\"failed\":${FAILED}},"
          done
          # Remove trailing comma and close
          PLATFORMS_JSON="${PLATFORMS_JSON%,}}"

          # Write metrics to timestamped file (eliminates append-only conflicts)
          METRICS_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          # Use timestamp in filename (with hyphens instead of colons for artifact compatibility)
          METRICS_TIMESTAMP_SAFE=$(echo "$METRICS_TIMESTAMP" | tr ':' '-')
          METRICS_FILE="data/metrics/batch-runs-${METRICS_TIMESTAMP_SAFE}.jsonl"

          # Read ecosystem breakdown from batch results
          ECOSYSTEMS_JSON="{}"
          RESULTS_FILE="data/queues/batch-results.json"
          if [ -f "$RESULTS_FILE" ] && [ -s "$RESULTS_FILE" ]; then
            ECOSYSTEMS_JSON=$(jq -c '.ecosystems // {}' "$RESULTS_FILE")
          fi

          jq -n \
            --arg batch_id "$BATCH_ID" \
            --argjson ecosystems "$ECOSYSTEMS_JSON" \
            --argjson total "$TOTAL" \
            --argjson generated "$GENERATED" \
            --argjson platforms "$PLATFORMS_JSON" \
            --argjson merged "$INCLUDED_COUNT" \
            --argjson excluded "$EXCLUDED_COUNT" \
            --argjson constrained "$CONSTRAINED_COUNT" \
            --arg timestamp "$METRICS_TIMESTAMP" \
            --argjson duration_seconds "$DURATION" \
            '{batch_id: $batch_id, ecosystems: $ecosystems, total: $total, generated: $generated, platforms: $platforms, merged: $merged, excluded: $excluded, constrained: $constrained, timestamp: $timestamp, duration_seconds: $duration_seconds}' \
            > "$METRICS_FILE"

          echo "SLI metrics written to $METRICS_FILE"

      - name: Check for recipes to merge
        if: steps.check-open-prs.outputs.should_skip != 'true'
        id: check
        run: |
          if git diff --quiet recipes/ && [ -z "$(git ls-files --others --exclude-standard recipes/)" ]; then
            echo "changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "changes=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Persist circuit breaker and metrics state
        if: steps.check-open-prs.outputs.should_skip != 'true' && steps.check.outputs.changes == 'false'
        run: |
          git add batch-control.json data/metrics/ 2>/dev/null || true
          if git diff --cached --quiet; then
            echo "No state changes to persist"
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git commit -m "chore(batch): update batch state"

          # Push with retry logic (3 attempts, exponential backoff)
          for attempt in 1 2 3; do
            if [ $attempt -gt 1 ]; then
              echo "::warning::Push attempt $attempt after failure"
              git pull --rebase --autostash origin main || { echo "::error::Rebase failed"; exit 1; }
              sleep $((2 ** attempt))
            fi
            if git push; then
              echo "Push succeeded on attempt $attempt"
              exit 0
            fi
          done
          echo "::error::Push failed after 3 attempts"
          exit 1
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Create pull request
        if: steps.check-open-prs.outputs.should_skip != 'true' && steps.check.outputs.changes == 'true'
        run: |
          # Update queue statuses for processed recipes using batch results
          QUEUE_FILE="data/queues/priority-queue.json"
          RESULTS_FILE="data/queues/batch-results.json"
          if [ -f "$RESULTS_FILE" ] && [ -s "$RESULTS_FILE" ]; then
            # Mark succeeded entries
            for pkg_id in $(jq -r '.recipes // [] | .[]' "$RESULTS_FILE" 2>/dev/null | while read -r path; do basename "$path" .toml; done); do
              # Find the matching queue entry by name
              jq --arg name "$pkg_id" \
                '(.packages[] | select(.name == $name)).status = "success"' \
                "$QUEUE_FILE" > tmp.json && mv tmp.json "$QUEUE_FILE"
            done
          fi
          for recipe in $EXCLUDED_RECIPES; do
            jq --arg name "$recipe" \
              '(.packages[] | select(.name == $name)).status = "failed"' \
              "$QUEUE_FILE" > tmp.json && mv tmp.json "$QUEUE_FILE"
          done

          # Sync with latest main to avoid race conditions with other workflows
          git fetch origin main
          git rebase --autostash origin/main

          BRANCH="batch/$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BRANCH"
          git add recipes/ data/ batch-control.json
          git reset HEAD -- data/batch-summary.md 2>/dev/null || true
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          TOTAL=$((INCLUDED_COUNT + EXCLUDED_COUNT))
          if [ "$TOTAL" -gt 0 ]; then
            SUCCESS_RATE=$(awk "BEGIN {printf \"%.2f\", $INCLUDED_COUNT / $TOTAL}")
          else
            SUCCESS_RATE="0.00"
          fi

          # Read ecosystem breakdown for commit message
          ECO_SUMMARY=""
          RESULTS_FILE="data/queues/batch-results.json"
          if [ -f "$RESULTS_FILE" ] && [ -s "$RESULTS_FILE" ]; then
            ECO_SUMMARY=$(jq -r '.ecosystems // {} | to_entries | map("\(.value) \(.key)") | join(", ")' "$RESULTS_FILE")
          fi

          # Build structured commit message with git trailers
          {
            echo "feat(recipes): add batch ${BATCH_ID} recipes"
            echo ""
            if [ -n "$ECO_SUMMARY" ]; then
              echo "Batch generation of ${TOTAL} packages ($ECO_SUMMARY)."
            else
              echo "Batch generation of ${TOTAL} packages."
            fi
            echo "- ${INCLUDED_COUNT} passed validation across platform environments"
            echo "- ${EXCLUDED_COUNT} excluded (recorded to data/failures/)"
            echo ""
            echo "batch_id: ${BATCH_ID}"
            echo "batch_size: ${TOTAL}"
            echo "success_rate: ${SUCCESS_RATE}"
          } > /tmp/commit-msg.txt

          git commit -F /tmp/commit-msg.txt
          git push -u origin "$BRANCH"

          # Build PR body with platform validation summary and ecosystem breakdown
          RECIPE_COUNT=$(git diff --name-only main -- recipes/ | wc -l)
          {
            if [ -n "$ECO_SUMMARY" ]; then
              echo "Batch recipe generation ($ECO_SUMMARY): ${INCLUDED_COUNT} recipes included, ${EXCLUDED_COUNT} excluded."
            else
              echo "Batch recipe generation: ${INCLUDED_COUNT} recipes included, ${EXCLUDED_COUNT} excluded."
            fi
            echo ""
            echo "Validated across 11 platform environments (5 Linux x86_64 families, 4 Linux arm64 families, 2 macOS)."
            if [ "$CONSTRAINED_COUNT" -gt 0 ]; then
              echo ""
              echo "## Platform Constraints"
              echo ""
              echo "${CONSTRAINED_COUNT} recipe(s) have partial platform coverage. Constraints were derived automatically:"
              cat /tmp/constraint-log.md 2>/dev/null || true
            fi
            if [ "$EXCLUDED_COUNT" -gt 0 ]; then
              echo ""
              echo "## Excluded Recipes"
              echo ""
              cat /tmp/excluded-log.md 2>/dev/null || true
            fi
            echo ""
            echo "---"
            echo ""
            echo "## Validation Summary"
            echo ""
            echo "| Platform | Status |"
            echo "|----------|--------|"
            for platform in linux-x86_64 linux-arm64 darwin-arm64 darwin-x86_64; do
              COUNT=$(jq "length" "validation-results-${platform}.json" 2>/dev/null || echo "0")
              if [ "$COUNT" = "0" ]; then
                echo "| ${platform} | No results (infrastructure failure or not yet implemented) |"
              else
                PASS=$(jq '[.[] | select(.status == "pass")] | length' "validation-results-${platform}.json")
                FAIL=$(jq '[.[] | select(.status == "fail")] | length' "validation-results-${platform}.json")
                echo "| ${platform} | ${PASS} passed, ${FAIL} failed |"
              fi
            done
          } > /tmp/pr-body.md

          PR_URL=$(gh pr create \
            --title "feat(recipes): add batch recipes (${INCLUDED_COUNT} recipes)" \
            --body-file /tmp/pr-body.md \
            --base main)
          echo "PR_URL=$PR_URL" >> "$GITHUB_ENV"
          echo "Created PR: $PR_URL"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Enable auto-merge or post review notice
        if: steps.check-open-prs.outputs.should_skip != 'true' && steps.check.outputs.changes == 'true'
        run: |
          PR_NUMBER=$(echo "$PR_URL" | grep -o '[0-9]*$')
          if [ "$EXCLUDED_COUNT" -eq 0 ]; then
            echo "All recipes passed validation  enabling auto-merge"
            MERGE_ARGS=(--squash
              --subject "feat(recipes): add batch recipes (${INCLUDED_COUNT} recipes)"
              --body "Batch generation of ${INCLUDED_COUNT} packages. All recipes passed validation across platform environments.")
            if ! gh pr merge "$PR_NUMBER" --auto "${MERGE_ARGS[@]}" 2>&1; then
              echo "Auto-merge unavailable  waiting for CI checks to complete"
              if gh pr checks "$PR_NUMBER" --watch --fail-fast; then
                echo "All CI checks passed  merging"
                gh pr merge "$PR_NUMBER" "${MERGE_ARGS[@]}"
              else
                echo "::error::CI checks failed  not merging automatically"
                gh pr comment "$PR_NUMBER" --body "Auto-merge was skipped because CI checks failed. Please review the failures and merge manually after fixing."
                exit 1
              fi
            fi
          else
            echo "Some recipes were excluded  skipping auto-merge"
            gh pr comment "$PR_NUMBER" --body "Auto-merge was not enabled because ${EXCLUDED_COUNT} recipe(s) were excluded during validation. Please review the excluded recipes and merge manually."
          fi
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
