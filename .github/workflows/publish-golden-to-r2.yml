# Publish golden files to R2 storage after merge.
#
# This workflow is triggered:
# 1. Automatically on push to main when recipe files change
# 2. Manually via workflow_dispatch with specific recipes
#
# The workflow generates golden files on all supported platforms and uploads
# them to the R2 bucket for use by nightly validation.
#
# See docs/designs/DESIGN-r2-golden-storage.md for architecture details.
name: Publish Golden Files to R2

on:
  push:
    branches: [main]
    paths:
      - 'recipes/**/*.toml'
      - 'internal/recipe/recipes/**/*.toml'

  workflow_dispatch:
    inputs:
      recipes:
        description: 'Comma-separated list of recipe names (e.g., fzf,ripgrep,bat)'
        required: true
        type: string
      force:
        description: 'Force regenerate even if version already exists in R2'
        type: boolean
        default: false

# Prevent concurrent runs for the same trigger type
concurrency:
  group: publish-golden-${{ github.event_name }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'workflow_dispatch' }}

jobs:
  detect-recipes:
    name: Detect Recipes
    runs-on: ubuntu-latest
    outputs:
      recipes: ${{ steps.detect.outputs.recipes }}
      has_recipes: ${{ steps.detect.outputs.has_recipes }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 2  # Need previous commit for diff

      - name: Detect changed recipes
        id: detect
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Parse comma-separated input
            INPUT="${{ inputs.recipes }}"
            echo "Manual trigger with recipes: $INPUT"

            # Build JSON array
            JSON="["
            FIRST=true
            IFS=',' read -ra RECIPES <<< "$INPUT"
            for recipe in "${RECIPES[@]}"; do
              recipe=$(echo "$recipe" | xargs)  # Trim whitespace
              [ -z "$recipe" ] && continue

              # Detect category from file existence
              first_letter="${recipe:0:1}"
              if [ -f "internal/recipe/recipes/$recipe.toml" ]; then
                category="embedded"
              elif [ -f "recipes/$first_letter/$recipe.toml" ]; then
                category="registry"
              else
                echo "::warning::Recipe not found: $recipe"
                continue
              fi

              [ "$FIRST" = true ] && FIRST=false || JSON="$JSON,"
              JSON="$JSON{\"recipe\":\"$recipe\",\"category\":\"$category\"}"
            done
            JSON="$JSON]"
          else
            # Push trigger: detect changed recipes via git diff
            echo "Push trigger, detecting changed recipes..."

            CHANGED=$(git diff --name-only --diff-filter=d HEAD~1 HEAD -- 'internal/recipe/recipes/**/*.toml' 'recipes/**/*.toml' || true)

            if [ -z "$CHANGED" ]; then
              echo "No recipe files changed"
              echo "has_recipes=false" >> $GITHUB_OUTPUT
              echo "recipes=[]" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "Changed files:"
            echo "$CHANGED"

            # Build JSON array
            JSON="["
            FIRST=true
            for path in $CHANGED; do
              [ ! -f "$path" ] && continue

              recipe=$(basename "$path" .toml)

              if [[ "$path" == internal/recipe/recipes/* ]]; then
                category="embedded"
              else
                category="registry"
              fi

              [ "$FIRST" = true ] && FIRST=false || JSON="$JSON,"
              JSON="$JSON{\"recipe\":\"$recipe\",\"category\":\"$category\"}"
            done
            JSON="$JSON]"
          fi

          echo "Recipes to process: $JSON"

          if [ "$JSON" = "[]" ]; then
            echo "has_recipes=false" >> $GITHUB_OUTPUT
          else
            echo "has_recipes=true" >> $GITHUB_OUTPUT
          fi
          echo "recipes=$JSON" >> $GITHUB_OUTPUT

  generate:
    name: "Generate: ${{ matrix.platform.name }}"
    needs: detect-recipes
    if: needs.detect-recipes.outputs.has_recipes == 'true'
    runs-on: ${{ matrix.platform.runner }}
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { runner: ubuntu-latest, name: "Linux x86_64", os: linux, arch: amd64 }
          - { runner: macos-14, name: "macOS Apple Silicon", os: darwin, arch: arm64 }
          - { runner: macos-15-intel, name: "macOS Intel", os: darwin, arch: amd64 }
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version-file: 'go.mod'
          cache-dependency-path: go.sum

      - name: Build tsuku
        run: CGO_ENABLED=0 go build -o tsuku ./cmd/tsuku

      - name: Generate golden files
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p artifacts

          RECIPES='${{ needs.detect-recipes.outputs.recipes }}'
          echo "Processing recipes: $RECIPES"

          # Process each recipe
          echo "$RECIPES" | jq -c '.[]' | while read -r item; do
            recipe=$(echo "$item" | jq -r '.recipe')
            category=$(echo "$item" | jq -r '.category')

            echo "Generating golden files for $recipe ($category) on ${{ matrix.platform.os }}-${{ matrix.platform.arch }}..."

            # Generate golden files for this platform
            ./scripts/regenerate-golden.sh "$recipe" \
              --os "${{ matrix.platform.os }}" \
              --arch "${{ matrix.platform.arch }}" \
              --category "$category" || {
                echo "::warning::Failed to generate golden files for $recipe"
                continue
              }

            # Determine golden directory based on category
            if [ "$category" = "embedded" ]; then
              golden_dir="testdata/golden/plans/embedded/$recipe"
            else
              first_letter="${recipe:0:1}"
              golden_dir="testdata/golden/plans/$first_letter/$recipe"
            fi

            # Copy generated files to artifacts directory with metadata
            if [ -d "$golden_dir" ]; then
              for file in "$golden_dir"/*.json; do
                [ -f "$file" ] || continue

                # Extract version and platform from filename
                # Format: v1.0.0-linux-amd64.json or v1.0.0-linux-debian-amd64.json
                filename=$(basename "$file" .json)

                # Create subdirectory structure: artifacts/<category>/<recipe>/
                mkdir -p "artifacts/$category/$recipe"
                cp "$file" "artifacts/$category/$recipe/"
                echo "  Copied: $file"
              done
            fi
          done

          echo "Generation complete for ${{ matrix.platform.os }}-${{ matrix.platform.arch }}"

      - name: Upload artifacts
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: golden-${{ matrix.platform.os }}-${{ matrix.platform.arch }}
          path: artifacts/
          if-no-files-found: warn
          retention-days: 1

  upload-to-r2:
    name: Upload to R2
    needs: [detect-recipes, generate]
    if: needs.detect-recipes.outputs.has_recipes == 'true'
    runs-on: ubuntu-latest
    environment: registry-write
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Download all artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          path: artifacts/
          pattern: golden-*
          merge-multiple: true

      - name: List artifacts
        run: |
          echo "Downloaded artifacts:"
          find artifacts/ -name "*.json" -type f | head -50

      - name: Upload to R2
        env:
          R2_BUCKET_URL: ${{ secrets.R2_BUCKET_URL }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID_WRITE }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY_WRITE }}
          FORCE: ${{ inputs.force || 'false' }}
        run: |
          UPLOADED=0
          FAILED=0
          SKIPPED=0

          # Process each golden file in artifacts
          find artifacts/ -name "*.json" -type f | while read -r file; do
            # Parse path: artifacts/<category>/<recipe>/<version>-<platform>.json
            rel_path="${file#artifacts/}"
            category=$(echo "$rel_path" | cut -d'/' -f1)
            recipe=$(echo "$rel_path" | cut -d'/' -f2)
            filename=$(basename "$file" .json)

            # Parse version and platform from filename
            # Format: v{version}-{os}[-{family}]-{arch}.json
            # Examples:
            #   v0.60.0-linux-amd64.json -> version=0.60.0, platform=linux-amd64
            #   v2.11.0-beta.2-darwin-arm64.json -> version=2.11.0-beta.2, platform=darwin-arm64
            #   vbun-v1.3.6-darwin-amd64.json -> version=bun-v1.3.6, platform=darwin-amd64
            #   v1.0.0-linux-debian-amd64.json -> version=1.0.0, platform=linux-debian-amd64
            #
            # Strategy: Find the OS marker (linux/darwin) to split version from platform

            # Find platform by looking for -linux- or -darwin-
            if [[ "$filename" =~ -linux- ]]; then
              # Extract everything after -linux- (including linux itself)
              # Handle family-aware: -linux-debian-amd64
              after_linux="${filename#*-linux-}"
              # Check if first part after linux is a family
              first_part=$(echo "$after_linux" | cut -d'-' -f1)
              if [[ "$first_part" =~ ^(debian|rhel|arch|alpine|suse)$ ]]; then
                # Family-aware: linux-family-arch
                platform="linux-${first_part}-$(echo "$after_linux" | cut -d'-' -f2)"
              else
                # Family-agnostic: linux-arch
                platform="linux-${first_part}"
              fi
              # Version is everything before -linux-
              version="${filename%-linux-*}"
            elif [[ "$filename" =~ -darwin- ]]; then
              # darwin is always family-agnostic
              after_darwin="${filename#*-darwin-}"
              platform="darwin-${after_darwin}"
              version="${filename%-darwin-*}"
            else
              echo "::warning::Could not parse platform from filename: $filename"
              continue
            fi

            # Remove 'v' prefix from version for upload script
            version_no_v="${version#v}"

            echo "Processing: $recipe @ $version_no_v ($platform) [$category]"

            # Upload to R2
            if ./scripts/r2-upload.sh --category "$category" "$recipe" "$version_no_v" "$platform" "$file"; then
              echo "  Uploaded successfully"
              UPLOADED=$((UPLOADED + 1))
            else
              echo "::warning::Failed to upload $file"
              FAILED=$((FAILED + 1))
            fi
          done

          echo ""
          echo "Upload summary:"
          echo "  Uploaded: $UPLOADED"
          echo "  Failed: $FAILED"

          # Fail if all uploads failed
          if [ "$UPLOADED" -eq 0 ] && [ "$FAILED" -gt 0 ]; then
            echo "::error::All uploads failed"
            exit 1
          fi
