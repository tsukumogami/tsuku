# Security Review: DESIGN-structured-json-output.md

## Executive Summary

This design adds structured JSON error output to the `tsuku install` command. The security analysis in the design document is **incomplete**. While the identified "not applicable" justifications are technically correct for the direct changes, the design misses several attack vectors relevant to tsuku's threat model as a tool that downloads and executes binaries.

**Severity Assessment:** Medium
- No critical vulnerabilities introduced
- Several missing considerations that should be documented
- Residual risks exist but are manageable with proper mitigation

## Detailed Analysis

### 1. Attack Vectors Not Considered

#### 1.1 Information Disclosure Through Error Messages (Medium Risk)

**Issue:** The design states that error messages "may include file paths from the user's system" and dismisses this as already present in stderr. However, JSON output has different exposure characteristics:

- **Structured persistence**: JSON errors are more likely to be logged to files, bug trackers, or telemetry systems than ad-hoc stderr
- **Automated collection**: CI systems and orchestrators may automatically collect JSON output and send it to centralized logging
- **Nested error unwrapping**: The `extractMissingRecipes()` function uses regex on the full error chain, which may include internal stack traces or system paths not visible in normal stderr output

**Example Attack Scenario:**
1. User has custom `$TSUKU_HOME` at `/home/sensitive-project/tools/`
2. Install fails with dependency error
3. JSON output includes full path in error message
4. Orchestrator logs JSON to shared CI logs
5. Path reveals internal project structure or usernames

**Current State:** Error messages already expose paths, but JSON makes collection and aggregation easier.

**Recommendation:** Document this explicitly and add a note about sanitizing JSON output before sending to telemetry or external systems.

#### 1.2 JSON Injection / Structure Manipulation (Low Risk)

**Issue:** The `InstallError` struct includes user-controlled data (recipe names) in the `missing_recipes` field. While recipe names are validated before download, error paths might include names from failed validation.

**Attack Scenario:**
1. Attacker creates a malicious recipe with special characters in dependencies
2. Recipe validation fails
3. Dependency name includes JSON metacharacters: `recipe-name\"\n,\"extra_field\":\"injected`
4. JSON output becomes malformed or includes injected fields
5. Orchestrator parsing breaks or exhibits unexpected behavior

**Mitigation Already Present:** Go's `json.Marshal()` automatically escapes strings, so this is mostly theoretical. However, the design doesn't explicitly acknowledge that recipe names in error messages are untrusted input.

**Recommendation:** Add a security note that `json.Marshal()` provides automatic escaping for untrusted recipe names.

#### 1.3 Error Message Confusion Attacks (Low Risk)

**Issue:** The `classifyInstallError()` function uses string matching on error messages to determine exit codes. An attacker who can influence error messages could potentially cause misclassification.

**Attack Scenario:**
1. Malicious recipe server returns HTTP error with body containing "not found in registry"
2. Network error message includes this text
3. `classifyInstallError()` misclassifies network error as missing recipe (exit code 3 instead of 5)
4. Orchestrator treats network errors as validation failures
5. Valid recipes are incorrectly marked as broken

**Current Likelihood:** Low - error messages are generated by tsuku's own code, not external sources. Network errors use standard library error types.

**Recommendation:** Document that error classification depends on message stability and add tests for edge cases where external error text might appear in wrapped errors.

#### 1.4 Denial of Service Through Large Error Objects (Low Risk)

**Issue:** The `missing_recipes` array could grow unbounded if a recipe has hundreds of missing dependencies (e.g., through a malicious recipe or circular dependency bug).

**Attack Scenario:**
1. Malicious recipe declares 10,000 dependencies
2. None exist in the registry
3. `extractMissingRecipes()` builds an array with 10,000 entries
4. JSON output becomes multi-megabyte
5. Orchestrator or CI system runs out of memory parsing the response

**Current Mitigations:**
- Recipe validation likely limits dependency count
- Orchestrator is internal tooling with known recipe sources

**Recommendation:** Add a note about bounding the `missing_recipes` array (e.g., max 100 entries, or "...and 95 more" truncation) if used with untrusted recipes.

### 2. Evaluation of "Not Applicable" Justifications

#### 2.1 Download Verification - VALID

**Justification:** "This change affects error reporting, not how artifacts are downloaded or verified."

**Analysis:** Correct. The design only changes output format after errors occur. Download and verification logic is unchanged.

**Verdict:** Valid "not applicable"

#### 2.2 Execution Isolation - PARTIALLY VALID

**Justification:** "No new execution paths. The `--json` flag changes output format, not what code runs."

**Analysis:** Mostly correct, but incomplete. While the flag doesn't add new execution paths, it does add a new parsing path in the orchestrator (JSON unmarshaling). This introduces a dependency on the `encoding/json` package's security properties.

**Missing Consideration:** What happens if JSON parsing fails in the orchestrator? Does it fall back gracefully or crash?

**Verdict:** Valid "not applicable" for the CLI side, but should mention orchestrator parsing safety.

#### 2.3 Supply Chain Risks - VALID

**Justification:** "No changes to artifact sources or verification."

**Analysis:** Correct. The design doesn't touch recipe downloading, signature verification, or binary execution.

**Verdict:** Valid "not applicable"

#### 2.4 User Data Exposure - INCOMPLETE

**Justification:** "These paths already appear in stderr output today, so the JSON flag doesn't expose new information -- it just structures what's already printed."

**Analysis:** Technically true but misses the point. Structured data has different exposure characteristics:
- Easier to accidentally log to persistent storage
- More likely to be included in automated error reporting
- Can be parsed and aggregated at scale

The design should acknowledge this and recommend sanitization practices for consumers.

**Verdict:** Technically valid but practically incomplete. Should be expanded.

### 3. Sufficiency of Mitigations

The design document lists two mitigations in the "Mitigations" section under "Consequences":

#### 3.1 String Matching Fragility

**Mitigation:** "`classifyInstallError` matches on strings that come from code we control... changes would be caught by tests."

**Analysis:** This mitigates accidental breakage from refactoring but doesn't address intentional manipulation (see Attack Vector 1.3). However, since tsuku controls all error message sources, this is acceptable for the current threat model.

**Sufficiency:** Adequate for internal use. Would need hardening for untrusted error sources.

#### 3.2 JSON Schema Evolution

**Mitigation:** "The JSON struct is simple (5 fields) and internal. Adding fields is backward-compatible... caught at compile time (or test time)."

**Analysis:** This addresses breaking changes but doesn't mention security properties of the JSON parser or bounds on output size.

**Sufficiency:** Adequate for version compatibility. Missing considerations for DoS and error message sanitization.

### 4. Missing Security Sections

The design document should include:

#### 4.1 Threat Model Clarification

**What should be added:**
```markdown
### Threat Model Scope

This feature assumes:
- Recipe sources are trusted (Homebrew registry or local files)
- The batch orchestrator is internal tooling, not exposed to external input
- Error messages are consumed only by tsuku developers and CI systems

Out of scope:
- Protection against malicious recipe content (handled by recipe validation)
- Sanitization for public bug reports (users must redact paths manually)
- Rate limiting or DoS protection (orchestrator is not a service)
```

#### 4.2 Secure Consumption Guidelines

**What should be added:**
```markdown
### Secure Usage of JSON Output

When consuming `--json` output:
1. **Logging**: Sanitize file paths before logging to shared systems
2. **Telemetry**: Do not send raw JSON errors to external analytics
3. **Error handling**: Validate JSON structure before parsing to avoid crashes
4. **Size limits**: Consider truncating `missing_recipes` arrays in UI display

Example sanitization:
```go
func sanitizePath(path string) string {
    home := os.Getenv("HOME")
    return strings.Replace(path, home, "$HOME", -1)
}
```
```

#### 4.3 Input Validation

**What should be added:**
```markdown
### Input Validation in JSON Path

The `missing_recipes` field contains recipe names extracted from error messages. While Go's `json.Marshal()` automatically escapes special characters, consumers should:
- Validate that array length is reasonable (< 1000 entries)
- Treat recipe names as untrusted when displaying in UI
- Not execute or evaluate recipe names as code

The orchestrator already validates recipe names before processing, providing defense in depth.
```

### 5. Residual Risks

After implementing recommended mitigations, the following residual risks remain:

#### 5.1 Accidental Information Disclosure (Low)

**Risk:** Developers may accidentally commit logs containing JSON output with sensitive paths.

**Acceptance Rationale:** This is a general operational risk, not specific to JSON output. Existing processes (code review, gitignore) provide adequate protection.

**Escalation:** Not necessary. Document in usage guidelines.

#### 5.2 Error Classification Bypass (Very Low)

**Risk:** Future refactoring might change error message text, breaking `classifyInstallError()` string matching.

**Acceptance Rationale:** Tests will catch this. The CLI and orchestrator are in the same repo with integrated testing.

**Escalation:** Not necessary. Existing test coverage is sufficient.

#### 5.3 JSON Parsing Vulnerabilities (Very Low)

**Risk:** Bugs in Go's `encoding/json` package could cause crashes or memory issues.

**Acceptance Rationale:** Standard library is well-tested. Tsuku already uses JSON parsing in other commands.

**Escalation:** Not necessary. General dependency management applies.

## Recommendations

### Critical (Must Address Before Merge)

None. The design is fundamentally sound from a security perspective.

### High Priority (Should Address Before Merge)

1. **Expand User Data Exposure section** to acknowledge structured data exposure characteristics and recommend sanitization for logging/telemetry
2. **Add bounds check** to `extractMissingRecipes()` to limit array size (e.g., max 100 entries)
3. **Add error handling** example for orchestrator JSON parsing failures

### Medium Priority (Should Address in Implementation)

4. **Add unit tests** for edge cases:
   - Error messages containing JSON metacharacters in recipe names
   - Very large `missing_recipes` arrays
   - Malformed JSON handling in orchestrator
5. **Document secure consumption guidelines** in code comments where orchestrator parses JSON
6. **Add telemetry sanitization** note if tsuku has telemetry plans for error reporting

### Low Priority (Nice to Have)

7. **Consider path sanitization** helper for error messages (replace `$HOME` with literal)
8. **Add schema validation** in orchestrator to fail fast on unexpected JSON structure
9. **Document threat model** explicitly in Security Considerations section

## Conclusion

The security analysis in the design document is **adequate but incomplete**. The identified "not applicable" justifications are technically correct for the direct code changes, but the design misses important considerations about how structured error data differs from unstructured stderr.

**Key Findings:**
- No critical vulnerabilities introduced
- Primary risk is accidental information disclosure through aggregated JSON logs
- Mitigations are mostly implicit (Go's JSON escaping, same-repo testing)
- Documentation should be enhanced to guide secure consumption

**Recommendation:** Approve the design with **required changes** to expand the User Data Exposure section and add bounds checking for error arrays. Other recommendations can be addressed during implementation.

**Risk Level After Mitigations:** Low
- All identified risks have acceptable workarounds
- No residual risks require escalation beyond documentation
- The design is appropriate for tsuku's current threat model (internal tooling, trusted recipe sources)
