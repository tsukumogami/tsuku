# Design: Self-Contained Installation Plans

## Status

Proposed

## Context and Problem Statement

Issue #805 revealed that sandbox execution fails for recipes requiring implicit action dependencies (build tools like `cmake`, `zig`, `make`, `pkg-config`). Investigation uncovered a deeper architectural problem: **installation plans are not truly self-contained**.

Currently, three different code paths exist for installation:

1. **`tsuku install foo`**: Installs implicit dependencies before plan generation, then generates a plan with `RecipeLoader=nil` (no dependencies embedded)
2. **`tsuku eval foo`**: Generates a plan with `RecipeLoader=loader` (includes all dependencies)
3. **`tsuku install --plan plan.json`**: Loads and executes a plan (may or may not have dependencies)

This divergence violates the core architecture principle: **plans must be self-contained and executable without recipe context**.

### Impact

- **Plans from `eval` cannot be executed on different machines** - Dependencies are missing from plans generated by `install`
- **Sandbox testing doesn't validate real behavior** - Sandbox uses a different code path than normal installation
- **Three installation flows instead of one** - Harder to maintain, test, and reason about

### Root Cause

The `install` command passes `RecipeLoader: nil` to plan generation (cmd/tsuku/install_deps.go:478), which disables the dependency embedding infrastructure that already exists in the executor since format v3 (#621).

### Out of Scope

Cross-platform plan execution (e.g., generating a plan on macOS and executing on Linux) is not a goal. Plans are platform-specific artifacts.

## Decision Drivers

1. **Plan portability**: Plans must be executable on any machine with the same platform without recipe context
2. **Single code path**: `tsuku eval foo`, `tsuku install foo`, and `tsuku install --plan` must use identical plan generation
3. **Sandbox validation**: Sandbox tests must validate the same execution path used in production
4. **Backward compatibility**: Existing plans without dependencies must continue to work
5. **Minimal changes**: Leverage existing format v3 infrastructure rather than redesigning

## Considered Options

### Option 1: Install Dependencies Before Sandbox Execution

**Approach**: Install implicit dependencies on the host before sandbox execution, then mount `$TSUKU_HOME/tools/` into the container.

**Pros**:
- No changes to plan format
- Dependencies available in sandbox immediately

**Cons**:
- **Violates architecture principle**: Plans require recipe context at execution time
- **Breaks plan portability**: Cannot `tsuku eval foo > plan.json` on Machine A and `tsuku install --plan plan.json` on Machine B
- **Invalidates sandbox testing**: Sandbox doesn't test the same code path as production
- **Requires separate installation mode**: Maintains divergent code paths

**Verdict**: **REJECTED** - Fundamentally incompatible with self-contained plans.

### Option 2: Include Implicit Dependencies in Plan

**Approach**: Enable the existing format v3 dependency embedding by providing `RecipeLoader` during plan generation in the `install` command.

**Pros**:
- **Already implemented**: Format v3 (#621) supports recursive dependency trees
- **Single code path**: All installation modes use the same plan generation and execution
- **Truly portable**: Plans include everything needed for execution
- **Minimal code changes**: One line changed, ~30 lines deleted
- **No schema changes**: Uses existing `InstallationPlan.Dependencies` field
- **Backward compatible**: Old plans without dependencies still work

**Cons**:
- Larger plan files (includes full dependency trees)
- Slower plan generation (must resolve all dependency versions)
- Potential redundant installations when eval and install run on same host

**Mitigations**:
- Plan size increase is negligible (dependency metadata is small)
- Plan caching already exists (slow generation happens once)
- Redundant installations are idempotent (state check skips if already installed, ~10ms overhead)

**Verdict**: **CHOSEN** - Aligns with architecture, reuses existing infrastructure, minimal implementation cost.

### Option 3: Re-derive Dependencies from Plan Steps

**Approach**: Parse the plan's resolved steps to extract implicit dependencies at execution time.

**Pros**:
- No changes to plan format
- No need for RecipeLoader during plan generation

**Cons**:
- **Cannot handle platform-specific dependencies**: Recipe-level context is needed to resolve dependencies correctly
- **Duplicates resolution logic**: Plan generation already calls `ResolveDependencies(recipe)`
- **Fragile**: Depends on step naming conventions, breaks if step format changes
- **Still requires recipe context**: Must re-load recipes for dependencies, defeating the purpose

**Verdict**: **REJECTED** - Duplicates logic, requires recipe context anyway.

### Option 4: Pass Recipe to Sandbox Executor

**Approach**: Modify the sandbox executor to accept the recipe alongside the plan.

**Pros**:
- Sandbox can resolve dependencies at execution time
- No changes to plan format

**Cons**:
- **Violates separation of concerns**: Plan execution should not require recipe context
- **Doesn't solve general portability**: Only fixes sandbox, not `tsuku install --plan`
- **Adds complexity**: Sandbox interface now requires two inputs instead of one
- **Breaks the architecture**: Plans are no longer self-contained

**Verdict**: **REJECTED** - Fixes the symptom, not the root cause.

## Decision Outcome

**Chosen: Option 2 - Include Implicit Dependencies in Plan**

The fix is to enable the dependency embedding infrastructure that already exists in the executor by providing `RecipeLoader` during plan generation in the `install` command.

### Rationale

1. **Reuses existing infrastructure**: Format v3 introduced `InstallationPlan.Dependencies` in #621 to support recursive dependency trees. The code path already exists; it's just not enabled in `install`.
2. **Achieves architectural goal**: Plans become truly self-contained and portable (within the same platform).
3. **Minimal code changes**: One line changed (`RecipeLoader: loader` instead of `nil`), ~30 lines of workaround code deleted.
4. **No schema changes**: Format v3 already has everything needed.
5. **Backward compatible**: Old plans without dependencies continue to work (execution gracefully handles empty `Dependencies` array).

### Platform-Specific Plans

Plans are **platform-specific** but **recipe-context-independent**:

- A plan generated for `debian + amd64` includes all resolved steps and dependencies for that platform
- The plan can be executed on any `debian + amd64` machine via `tsuku install --plan`
- The plan **cannot** be executed on `alpine + amd64` or `darwin + amd64` (wrong platform)

**Portability model**:
```
Machine A (debian + amd64 + has nodejs):
  tsuku eval myapp --linux-family debian > plan.json
  → Plan includes nodejs dependency, all debian-specific steps

Machine B (debian + amd64 + fresh):
  tsuku install --plan plan.json
  → Validates platform matches (debian + amd64)
  → Installs nodejs from plan
  → Executes resolved steps
  → Success ✅

Machine C (alpine + amd64):
  tsuku install --plan plan.json
  → Validates platform matches (alpine + amd64)
  → Platform mismatch error ❌
```

### Redundant Installation is Intentional

For some ecosystems, generating a reproducible plan requires the toolchain to be installed. This means:

1. **`eval` scenario**: To generate a plan for an npm package, nodejs might need to be installed to resolve dependencies
2. **`install` on same host**: Dependencies already installed during eval → execution sees them and skips (cheap state check, ~10ms)
3. **`install` on different host**: Dependencies not installed → execution installs them (necessary!)

The eval/install split is **designed** for this:
- Eval runs on one machine (development, CI) with toolchain available
- Generated plan is portable
- Install runs on another machine (production, test container) and pulls in dependencies from the plan

The "redundancy" on the same host is a small performance cost (idempotent state check) for a large correctness guarantee (portability).

## Solution Architecture

### Unified Code Path

All installation modes use the same plan generation and execution:

```
Any command that installs:
  1. Load recipe
  2. GeneratePlan(RecipeLoader=loader)  // Same config for eval and install
       ↓
     generateDependencyPlans()
       ↓
     ResolveDependencies(recipe)  // Returns explicit + implicit deps
       ↓
     For each dependency: generateSingleDependencyPlan()
       ↓
     Returns InstallationPlan with Dependencies[] populated

  3. ExecutePlan(plan)
       ↓
     validatePlatformConstraints()  // NEW: Fail fast if platform mismatch
       ↓
     installDependencies(plan.Dependencies)  // Recursive depth-first
       ↓
     Execute main steps
```

### Plan Structure (Format v3)

```go
type InstallationPlan struct {
    PlatformConstraints PlatformConstraints  // Platform this plan was generated for
    Dependencies        []DependencyPlan      // Nested dependency tree (explicit + implicit)
    Steps               []ResolvedStep        // Resolved installation steps
}

type PlatformConstraints struct {
    OS          string  // "linux", "darwin", "windows"
    Arch        string  // "amd64", "arm64"
    LinuxFamily string  // "debian", "fedora", "alpine" (empty if OS != linux)
}

type DependencyPlan struct {
    Tool         string
    Version      string
    Dependencies []DependencyPlan  // Recursive!
    Steps        []ResolvedStep
}
```

**Note**: `PlatformConstraints` may need to be added to the schema if not already present in format v3. This will be investigated during implementation.

### Key Components

1. **Plan Generation** (`internal/executor/plan_generator.go:186-194`):
   - Already conditionally includes dependencies based on `RecipeLoader != nil`
   - Calls `generateDependencyPlans()` which invokes `actions.ResolveDependencies(recipe)`
   - `ResolveDependencies()` returns both explicit (from `recipe.metadata.dependencies`) and implicit (from action `Dependencies()` methods)

2. **Plan Execution** (`internal/executor/executor.go`):
   - Already handles `plan.Dependencies` via `installDependencies()`
   - Installs dependencies depth-first before executing main steps
   - NEW: Will add platform validation before installation begins

3. **Install Command** (`cmd/tsuku/install_deps.go`):
   - Currently passes `RecipeLoader: nil` (line 478) → FIX: Pass `RecipeLoader: loader`
   - Currently calls `ensurePackageManagersForRecipe()` before plan generation (line 392) → DELETE: Redundant
   - Currently calls `SetResolvedDeps()` workaround (lines 451-475) → DELETE: `buildResolvedDepsFromPlan()` handles it

## Implementation Approach

### Phase 1: Investigate Platform Constraints and Resource Limits

**Task**: Determine if `PlatformConstraints` already exists in format v3 plan schema and verify resource limit handling.

**Actions**:
- Read `internal/executor/plan.go` or equivalent to check `InstallationPlan` struct
- If missing, design minimal schema addition (may require format version bump to v4)
- Verify if dependency depth/breadth limits exist in plan generation
- Design backward compatibility strategy (fail-closed for security)

### Phase 2: Add Platform Validation and Resource Limits

**Task**: Add platform constraint validation to plan execution with fail-closed security posture.

**Changes**:
- Add `PlatformConstraints` to `InstallationPlan` struct (if not present)
- Populate `PlatformConstraints` during plan generation from current platform detection
- Add resource limit constants (max dependency depth: 5, max total dependencies: 100)
- Add `validatePlatformConstraints()` function to executor
- Add `validateResourceLimits()` to check dependency tree depth and breadth
- Call validations as first step in `ExecutePlan()`

**Implementation: validatePlatformConstraints()**
```go
func validatePlatformConstraints(plan *InstallationPlan, currentPlatform Platform) error {
    // Fail closed: reject plans without constraints (security over compatibility)
    if plan.PlatformConstraints == nil {
        return fmt.Errorf("plan missing platform constraints (unsafe for execution)")
    }

    if plan.PlatformConstraints.OS != currentPlatform.OS {
        return fmt.Errorf("platform mismatch: plan requires %s, current system is %s",
            plan.PlatformConstraints.OS, currentPlatform.OS)
    }

    if plan.PlatformConstraints.Arch != currentPlatform.Arch {
        return fmt.Errorf("architecture mismatch: plan requires %s, current system is %s",
            plan.PlatformConstraints.Arch, currentPlatform.Arch)
    }

    // Linux family check (only if OS is linux)
    if plan.PlatformConstraints.OS == "linux" &&
       plan.PlatformConstraints.LinuxFamily != currentPlatform.LinuxFamily {
        return fmt.Errorf("linux family mismatch: plan requires %s, current system is %s",
            plan.PlatformConstraints.LinuxFamily, currentPlatform.LinuxFamily)
    }

    return nil
}
```

**Implementation: validateResourceLimits()**
```go
const (
    MaxDependencyDepth = 5
    MaxTotalDependencies = 100
)

func validateResourceLimits(plan *InstallationPlan) error {
    totalDeps := 0
    maxDepth := 0

    var traverse func(deps []DependencyPlan, depth int) error
    traverse = func(deps []DependencyPlan, depth int) error {
        if depth > MaxDependencyDepth {
            return fmt.Errorf("dependency depth exceeds limit (%d > %d)", depth, MaxDependencyDepth)
        }
        if depth > maxDepth {
            maxDepth = depth
        }

        for _, dep := range deps {
            totalDeps++
            if totalDeps > MaxTotalDependencies {
                return fmt.Errorf("total dependencies exceed limit (%d > %d)",
                    totalDeps, MaxTotalDependencies)
            }
            if err := traverse(dep.Dependencies, depth+1); err != nil {
                return err
            }
        }
        return nil
    }

    return traverse(plan.Dependencies, 1)
}
```

**Backward Compatibility Strategy**:
Old plans without `PlatformConstraints` will be **rejected** (fail-closed) to prevent unsafe execution. Users must regenerate plans with the new format. This prioritizes security over compatibility.

**Override mechanism** (for emergency recovery):
```bash
# Force execution of old plan (unsafe, requires explicit flag)
tsuku install --plan plan.json --force-platform
```

**Example errors**:
```
Error: plan missing platform constraints (unsafe for execution)
Hint: Regenerate plan with: tsuku eval <recipe> --linux-family <family>

Error: platform mismatch
  Plan requires: linux/amd64 (debian)
  Current system: linux/amd64 (alpine)

Error: dependency depth exceeds limit (7 > 5)
Tool: deeply-nested-tool
Hint: This may indicate a circular dependency or malicious recipe
```

### Phase 3: Enable RecipeLoader and Remove Workarounds (Atomic)

**Important**: Phases 3 and 4 must be combined into a single atomic commit to avoid intermediate broken states.

**File**: `cmd/tsuku/install_deps.go`

**Change 1** (line ~478):
```go
// Before
planCfg := planRetrievalConfig{
    RecipeLoader: nil,  // Disables dependency embedding
}

// After
planCfg := planRetrievalConfig{
    RecipeLoader: loader,  // Enable dependency embedding
}
```

**Delete 1** (line ~392):
```go
// DELETE: ensurePackageManagersForRecipe installs deps BEFORE plan generation
// This is redundant once RecipeLoader is enabled (plan includes deps)
execPaths, err := ensurePackageManagersForRecipe(mgr, r, visited, telemetryClient)
if err != nil {
    return fmt.Errorf("failed to ensure package managers: %w", err)
}
```

**Delete 2** (lines ~451-475):
```go
// DELETE: SetResolvedDeps workaround
// buildResolvedDepsFromPlan() already handles this
exec.SetResolvedDeps(resolvedDeps)
```

**Total**: ~30 lines deleted, 1 line changed (plus platform validation and resource limits).

### Phase 4: Test Plan Portability

**Test 1: Plans are identical**
```bash
# Generate plan via eval
go build -o tsuku ./cmd/tsuku
./tsuku eval ninja --linux-family debian > plan-eval.json

# Generate plan internally via install (with debug logging to capture plan)
# Compare JSON output - should be identical
diff plan-eval.json plan-install-debug.json
```

**Test 2: Cross-machine execution**
```bash
# Generate plan on host
./tsuku eval ninja --linux-family debian > plan.json

# Execute in fresh container (same platform)
docker run -v $(pwd)/plan.json:/plan.json debian:bookworm-slim \
  /path/to/tsuku install --plan /plan.json

# Verify installation succeeded
docker run -v $(pwd)/plan.json:/plan.json debian:bookworm-slim \
  ninja --version
```

**Test 3: Platform mismatch detection**
```bash
# Generate plan for debian
./tsuku eval ninja --linux-family debian > plan-debian.json

# Try to execute on alpine (should fail fast)
docker run -v $(pwd)/plan-debian.json:/plan.json alpine:latest \
  /path/to/tsuku install --plan /plan.json

# Expected: "Error: plan platform mismatch: plan requires debian, current system is alpine"
```

### Phase 5: Validate Sandbox Tests

**Task**: Confirm sandbox tests now validate real execution path.

**Actions**:
- Run existing sandbox tests for recipes with implicit dependencies
- Verify tests pass (dependencies installed from plan, not pre-installed on host)
- Check CI logs to confirm multi-family testing works

## Security Considerations

### Download Verification

**No change from current behavior.**

Dependencies are installed using the same download and verification mechanisms as the main recipe:
- SHA256 checksum verification for all downloaded artifacts
- Checksums embedded in dependency recipes
- Download failure aborts installation

### Execution Isolation

**No change from current behavior.**

- Dependencies are installed to `$TSUKU_HOME/tools/{tool}-{version}/`
- Same isolation model as explicit dependencies
- Sandbox mode still uses container isolation (no additional privileges)

### Supply Chain Risks

**No change from current behavior.**

Implicit dependencies (build tools like `cmake`, `zig`) are installed from the same sources as explicit dependencies:
- Recipes define download sources (GitHub releases, official websites, etc.)
- Same trust model as any tsuku install
- No new external dependencies introduced

The change only affects **when** dependencies are installed (during plan execution instead of before plan generation), not **what** is installed or **how** it's verified.

### User Data Exposure

**Not applicable** - This change does not access or transmit user data.

The only data flowing through the system is:
- Recipe metadata (already public, defined in recipes/)
- Installation plans (generated locally, can be shared but contain no user data)
- Downloaded tool binaries (checksummed, same as current behavior)

### Additional Security Measures

This design introduces mitigations for risks that become more relevant with self-contained plans:

#### Resource Exhaustion (Dependency Bombs)

**Risk**: Malicious recipes could create exponentially-growing dependency trees (e.g., each dependency depends on 10 others, creating 10^n installations).

**Mitigation**: Hard limits on dependency tree depth (max 5 levels) and breadth (max 100 total dependencies). Plans exceeding these limits are rejected before any installation begins. See Phase 2 implementation for `validateResourceLimits()`.

**Residual risk**: Limits are conservative and may need tuning based on real-world usage. Legitimate complex tools might hit the limits (solvable by increasing constants or using explicit dependency management).

#### Platform Validation Bypass

**Risk**: Old plans without `PlatformConstraints` could bypass platform validation and execute on incompatible systems.

**Mitigation**: Fail-closed security posture. Plans without `PlatformConstraints` are rejected with error message instructing user to regenerate plan. Emergency override (`--force-platform`) requires explicit opt-in. See Phase 2 implementation for `validatePlatformConstraints()`.

**Residual risk**: Users might habitually use `--force-platform` if they encounter the error frequently during migration. Documentation should emphasize this flag is unsafe.

#### Plan Tampering

**Risk**: Plans are JSON files that can be modified between `eval` and `install`. Attackers with filesystem access could modify dependency URLs, remove checksums, or inject malicious steps.

**Out of scope for this design** - Plan integrity (signatures, embedded hashes, schema validation) is a broader concern affecting all plan-based execution, not specific to implicit dependencies. This should be addressed in a separate design for plan security.

**Current mitigations** (already exist):
- Checksums are embedded in dependency recipes (modifying plan URL still requires valid checksum)
- Schema validation at plan load time rejects malformed plans
- Plan generation and execution typically happen in same session (limited time window)

**Future work**: Consider cryptographic plan signatures in format v4 or later.

## Consequences

### Positive

1. **Plans are truly portable**: Generate once on a machine with toolchains, execute anywhere on the same platform
2. **Single code path**: Easier to maintain, test, and reason about (one flow instead of three)
3. **Sandbox tests validate real behavior**: CI tests the same execution path used in production
4. **Format v3 infrastructure proves its value**: Existing implementation just needs to be enabled
5. **Fail-fast platform validation**: Clear error messages when platform mismatches occur

### Negative

1. **Plan generation may be slower**: Must resolve all dependency versions during plan generation
2. **Plans are larger**: Include full dependency trees instead of being empty
3. **Potential redundant installations**: When eval and install run on the same host, dependencies might be installed twice

### Mitigations

1. **Plan caching already exists**: Slow generation happens once, cached plans are reused
2. **Plan size increase is negligible**: Dependency metadata is small (tool name, version, download URL)
3. **Redundancy is idempotent**: State manager checks if already installed, skips with ~10ms overhead (acceptable cost for correctness guarantee)
