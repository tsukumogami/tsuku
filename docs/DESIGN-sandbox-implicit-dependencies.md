# Design: Self-Contained Installation Plans

## Status

Proposed

## Context and Problem Statement

Issue #805 revealed that sandbox execution fails for recipes requiring implicit action dependencies (build tools like `cmake`, `zig`, `make`, `pkg-config`). Investigation uncovered a deeper architectural problem: **installation plans are not truly self-contained**.

Currently, three different code paths exist for installation:

1. **`tsuku install foo`**: Installs implicit dependencies before plan generation, then generates a plan with `RecipeLoader=nil` (no dependencies embedded)
2. **`tsuku eval foo`**: Generates a plan with `RecipeLoader=loader` (includes all dependencies)
3. **`tsuku install --plan plan.json`**: Loads and executes a plan (may or may not have dependencies)

This divergence violates the core architecture principle: **plans must be self-contained and executable without recipe context**.

### Impact

- **Plans from `eval` cannot be executed on different machines** - Dependencies are missing from plans generated by `install`
- **Sandbox testing doesn't validate real behavior** - Sandbox uses a different code path than normal installation
- **Three installation flows instead of one** - Harder to maintain, test, and reason about

### Root Cause

The `install` command passes `RecipeLoader: nil` to plan generation (cmd/tsuku/install_deps.go:478), which disables the dependency embedding infrastructure that already exists in the executor since format v3 (#621).

### Out of Scope

Cross-platform plan execution (e.g., generating a plan on macOS and executing on Linux) is not a goal. Plans are platform-specific artifacts.

## Decision Drivers

1. **Plan portability**: Plans must be executable on any machine with the same platform without recipe context
2. **Single code path**: `tsuku eval foo`, `tsuku install foo`, and `tsuku install --plan` must use identical plan generation
3. **Sandbox validation**: Sandbox tests must validate the same execution path used in production
4. **Minimal changes**: Leverage existing format v3 infrastructure rather than redesigning

## Considered Options

### Option 1: Install Dependencies Before Sandbox Execution

**Approach**: Install implicit dependencies on the host before sandbox execution, then mount `$TSUKU_HOME/tools/` into the container.

**Pros**:
- No changes to plan format
- Dependencies available in sandbox immediately

**Cons**:
- **Violates architecture principle**: Plans require recipe context at execution time
- **Breaks plan portability**: Cannot `tsuku eval foo > plan.json` on Machine A and `tsuku install --plan plan.json` on Machine B
- **Invalidates sandbox testing**: Sandbox doesn't test the same code path as production
- **Requires separate installation mode**: Maintains divergent code paths

**Verdict**: **REJECTED** - Fundamentally incompatible with self-contained plans.

### Option 2: Include Implicit Dependencies in Plan

**Approach**: Enable the existing format v3 dependency embedding by providing `RecipeLoader` during plan generation in the `install` command.

**Pros**:
- **Already implemented**: Format v3 (#621) supports recursive dependency trees
- **Single code path**: All installation modes use the same plan generation and execution
- **Truly portable**: Plans include everything needed for execution
- **Minimal code changes**: Add RecipeLoader field to planRetrievalConfig struct, thread it through plan generation (3-5 lines changed), delete ~109 lines of workaround code (entire parallel installation flow)
- **No schema changes**: Uses existing `InstallationPlan.Dependencies` field

**Cons**:
- Larger plan files (includes full dependency trees)
- Slower plan generation (must resolve all dependency versions)
- Potential redundant installations when eval and install run on same host

**Mitigations**:
- Plan size increase is negligible (dependency metadata is small)
- Plan caching already exists (slow generation happens once)
- Redundant installations are idempotent (state check skips if already installed, ~10ms overhead)

**Verdict**: **CHOSEN** - Aligns with architecture, reuses existing infrastructure, minimal implementation cost.

### Option 3: Re-derive Dependencies from Plan Steps

**Approach**: Parse the plan's resolved steps to extract implicit dependencies at execution time.

**Pros**:
- No changes to plan format
- No need for RecipeLoader during plan generation

**Cons**:
- **Cannot handle platform-specific dependencies**: Recipe-level context is needed to resolve dependencies correctly
- **Duplicates resolution logic**: Plan generation already calls `ResolveDependencies(recipe)`
- **Fragile**: Depends on step naming conventions, breaks if step format changes
- **Still requires recipe context**: Must re-load recipes for dependencies, defeating the purpose

**Verdict**: **REJECTED** - Duplicates logic, requires recipe context anyway.

### Option 4: Pass Recipe to Sandbox Executor

**Approach**: Modify the sandbox executor to accept the recipe alongside the plan.

**Pros**:
- Sandbox can resolve dependencies at execution time
- No changes to plan format

**Cons**:
- **Violates separation of concerns**: Plan execution should not require recipe context
- **Doesn't solve general portability**: Only fixes sandbox, not `tsuku install --plan`
- **Adds complexity**: Sandbox interface now requires two inputs instead of one
- **Breaks the architecture**: Plans are no longer self-contained

**Verdict**: **REJECTED** - Fixes the symptom, not the root cause.

## Decision Outcome

**Chosen: Option 2 - Include Implicit Dependencies in Plan**

The fix is to enable the dependency embedding infrastructure that already exists in the executor by providing `RecipeLoader` during plan generation in the `install` command.

### Rationale

1. **Reuses existing infrastructure**: Format v3 introduced `InstallationPlan.Dependencies` in #621 to support recursive dependency trees. The code path already exists; it's just not enabled in `install`.
2. **Achieves architectural goal**: Plans become truly self-contained and portable (within the same platform).
3. **Minimal code changes**: Add RecipeLoader to config struct and thread through plan generation (3-5 lines), delete entire parallel installation flow (~109 lines of workaround code including helper functions).
4. **No schema changes**: Format v3 already has everything needed.

### Platform-Specific Plans

Plans are **platform-specific** but **recipe-context-independent**:

- A plan generated for `debian + amd64` includes all resolved steps and dependencies for that platform
- The plan can be executed on any `debian + amd64` machine via `tsuku install --plan`
- The plan **cannot** be executed on `alpine + amd64` or `darwin + amd64` (wrong platform)

**Portability model**:
```
Machine A (debian + amd64 + has nodejs):
  tsuku eval myapp --linux-family debian > plan.json
  → Plan includes nodejs dependency, all debian-specific steps

Machine B (debian + amd64 + fresh):
  tsuku install --plan plan.json
  → Validates platform matches (debian + amd64)
  → Installs nodejs from plan
  → Executes resolved steps
  → Success ✅

Machine C (alpine + amd64):
  tsuku install --plan plan.json
  → Validates platform matches (alpine + amd64)
  → Platform mismatch error ❌
```

### Redundant Installation is Intentional

For some ecosystems, generating a reproducible plan requires the toolchain to be installed. This means:

1. **`eval` scenario**: To generate a plan for an npm package, nodejs might need to be installed to resolve dependencies
2. **`install` on same host**: Dependencies already installed during eval → execution sees them and skips (cheap state check, ~10ms)
3. **`install` on different host**: Dependencies not installed → execution installs them (necessary!)

The eval/install split is **designed** for this:
- Eval runs on one machine (development, CI) with toolchain available
- Generated plan is portable
- Install runs on another machine (production, test container) and pulls in dependencies from the plan

The "redundancy" on the same host is a small performance cost (idempotent state check) for a large correctness guarantee (portability).

## Solution Architecture

### Unified Code Path

All installation modes use the same plan generation and execution:

```
Any command that installs:
  1. Load recipe
  2. GeneratePlan(RecipeLoader=loader)  // Same config for eval and install
       ↓
     generateDependencyPlans()
       ↓
     ResolveDependencies(recipe)  // Returns explicit + implicit deps
       ↓
     For each dependency: generateSingleDependencyPlan()
       ↓
     Returns InstallationPlan with Dependencies[] populated

  3. ExecutePlan(plan)
       ↓
     validatePlatformConstraints()  // NEW: Fail fast if platform mismatch
       ↓
     installDependencies(plan.Dependencies)  // Recursive depth-first
       ↓
     Execute main steps
```

### Plan Structure (Format v3)

```go
type InstallationPlan struct {
    Platform     Platform          // Platform this plan was generated for
    Dependencies []DependencyPlan  // Nested dependency tree (explicit + implicit)
    Steps        []ResolvedStep    // Resolved installation steps
}

type Platform struct {
    OS          string `json:"os"`                     // "linux", "darwin", "windows"
    Arch        string `json:"arch"`                   // "amd64", "arm64"
    LinuxFamily string `json:"linux_family,omitempty"` // "debian", "fedora", "alpine" (empty for non-Linux)
}

type DependencyPlan struct {
    Tool         string
    Version      string
    Dependencies []DependencyPlan  // Recursive!
    Steps        []ResolvedStep
}
```

**Note**: The `LinuxFamily` field will be added to the existing `Platform` struct in internal/executor/plan.go. This extends the format v3 schema but remains backward compatible since the field uses `omitempty` (plans without LinuxFamily will continue to work).

### Platform Detection and Population

The `Platform` field in `InstallationPlan` must be populated during plan generation to enable platform-specific step filtering and execution-time validation.

#### When Platform is Populated

Platform detection occurs in `GeneratePlan()` (internal/executor/plan_generator.go) as the first step of plan generation:

```go
func GeneratePlan(ctx context.Context, cfg *PlanConfig) (*InstallationPlan, error) {
    // Step 1: Detect and populate platform constraints
    platform, err := detectPlatform(cfg)
    if err != nil {
        return nil, fmt.Errorf("failed to detect platform: %w", err)
    }

    // Step 2: Filter recipe steps by platform
    filteredSteps := filterStepsByPlatform(cfg.Recipe.Steps, platform)

    // Step 3: Resolve dependencies and generate nested plans
    // (dependencies inherit the same platform from parent)
    ...
}
```

Platform detection must happen **before** step filtering and **before** dependency resolution to ensure the entire dependency tree uses consistent platform constraints.

#### How Platform Values are Determined

**OS and Architecture** (always populated):
- Detected from Go runtime: `runtime.GOOS` and `runtime.GOARCH`
- These are compile-time constants reflecting the build platform
- Values: `linux/darwin/windows` for OS, `amd64/arm64/386` for Arch
- No user override (plans are inherently platform-specific)

**Linux Family** (linux-only, conditional):
- **Only populated if recipe uses family-specific steps**: Check if recipe has any steps with `when.linux_family` conditions
- **If recipe is family-agnostic**: Leave field empty for maximum portability (plan works on any Linux family)
- **If recipe has family-specific steps**:
  - **User override** (preferred): If `--linux-family` flag provided, use that value after validation
  - **Automatic detection** (fallback): Call `platform.DetectFamily()` which reads `/etc/os-release`
  - **Detection failure** (graceful degradation): Emit warning and leave field empty
- **Non-Linux platforms**: Field remains empty (omitted from JSON via `omitempty` tag)

#### Implementation Example

```go
func detectPlatform(cfg *PlanConfig) (Platform, error) {
    platform := Platform{
        OS:   runtime.GOOS,
        Arch: runtime.GOARCH,
    }

    // Linux family detection (only for linux AND only if recipe uses family-specific steps)
    if platform.OS == "linux" {
        if recipeHasFamilySpecificSteps(cfg.Recipe) {
            // Recipe needs family filtering - populate the field
            if cfg.LinuxFamily != "" {
                // User provided explicit override
                if !isValidLinuxFamily(cfg.LinuxFamily) {
                    return Platform{}, fmt.Errorf("invalid linux family: %s (must be debian, fedora, alpine, arch, or gentoo)", cfg.LinuxFamily)
                }
                platform.LinuxFamily = cfg.LinuxFamily
            } else {
                // Attempt automatic detection
                family, err := platform.DetectFamily()
                if err != nil {
                    // Log warning but continue without family filtering
                    if cfg.OnWarning != nil {
                        cfg.OnWarning("platform", fmt.Sprintf("failed to detect linux family: %v. Plan will filter steps by OS and Arch only. Use --linux-family to override.", err))
                    }
                    platform.LinuxFamily = "" // Empty (no family filtering)
                } else {
                    platform.LinuxFamily = family
                }
            }
        } else {
            // Recipe is family-agnostic - leave empty for max portability
            platform.LinuxFamily = ""
        }
    }

    return platform, nil
}

func recipeHasFamilySpecificSteps(recipe *Recipe) bool {
    for _, step := range recipe.Steps {
        if len(step.When.LinuxFamily) > 0 {
            return true
        }
    }
    return false
}
```

#### Dependency Inheritance

Platform constraints are **inherited by all dependencies**. Nested dependency plans receive the same `Platform` value as the root plan:

```go
func generateDependencyPlans(cfg *PlanConfig, deps map[string]string) ([]DependencyPlan, error) {
    for depName, depVersion := range deps {
        // Create config for dependency with SAME platform
        depCfg := &PlanConfig{
            RecipeLoader: cfg.RecipeLoader,
            OS:           cfg.OS,           // Same OS as parent
            Arch:         cfg.Arch,         // Same Arch as parent
            LinuxFamily:  cfg.LinuxFamily,  // Same LinuxFamily as parent
            // ...
        }

        depPlan, err := generateSingleDependencyPlan(depCfg, depName, depVersion, processed)
        // ...
    }
}
```

This ensures:
1. All steps in the dependency tree are filtered by the same platform
2. Platform validation at execution time applies to the entire plan
3. No cross-platform dependency resolution (which would be invalid)

**Note on LinuxFamily inheritance**: If the parent recipe has no family-specific steps (LinuxFamily is empty), dependencies inherit the empty value, allowing maximum portability. If the parent requires a specific family, all dependencies are resolved for that family.

### Key Components

1. **Plan Generation** (`internal/executor/plan_generator.go:186-194`):
   - Already conditionally includes dependencies based on `RecipeLoader != nil`
   - Calls `generateDependencyPlans()` which invokes `actions.ResolveDependencies(recipe)`
   - `ResolveDependencies()` returns both explicit (from `recipe.metadata.dependencies`) and implicit (from action `Dependencies()` methods)

2. **Plan Execution** (`internal/executor/executor.go`):
   - Already handles `plan.Dependencies` via `installDependencies()`
   - Installs dependencies depth-first before executing main steps
   - NEW: Will add platform validation before installation begins

3. **Install Command** (`cmd/tsuku/install_deps.go`):
   - Currently lacks `RecipeLoader` field in `planRetrievalConfig` struct (lines 22-31) → FIX: Add field, thread through to `executor.GeneratePlan()` call
   - Currently calls `ensurePackageManagersForRecipe()` before plan generation (line 392) → DELETE: Redundant (4 lines + 53 lines function definition + 27 lines helper)
   - Currently calls `SetResolvedDeps()` workaround (lines 451-475) → DELETE: `buildResolvedDepsFromPlan()` handles it (25 lines)

### Circular Dependency Detection

Circular dependencies are detected during plan generation and result in hard errors that prevent installation.

#### Detection Mechanism

The `ResolveDependencies()` function (internal/actions/resolver.go) tracks the dependency resolution path and detects cycles during transitive dependency resolution:

```go
// In resolver.go:347-351
for _, ancestor := range path {
    if ancestor == depName {
        cyclePath := append(path, depName)
        return fmt.Errorf("%w: %s", ErrCyclicDependency, strings.Join(cyclePath, " -> "))
    }
}
```

The `processed map[string]bool` in `generateDependencyPlans()` prevents infinite loops at the plan generation level, but `ResolveDependencies()` provides the authoritative cycle detection with full path information.

#### Error Handling

When a circular dependency is detected, plan generation fails immediately with a descriptive error message:

```
Error: circular dependency detected during plan generation
  Dependency chain: ninja -> cmake -> ninja

This indicates a recipe configuration error. Check:
  - Recipe metadata.dependencies fields
  - Action implicit dependencies
  - Step-level dependency overrides

Recipe maintainers should resolve this before the tool can be installed.
```

**Why hard error?** Circular dependencies make installation logically impossible. There is no valid installation order when A depends on B and B depends on A. This indicates a recipe misconfiguration that must be fixed by recipe maintainers.

#### Platform-Specific Cycles

Circular dependencies can be platform-specific due to conditional dependencies:

**Example**:
```toml
# patchelf.toml
[metadata]
name = "patchelf"

[[steps]]
action = "cargo_install"  # cargo has linux-specific dep on patchelf
when.os = ["linux"]
```

On Linux: `patchelf -> cargo -> patchelf` (cycle detected, error)
On macOS: `patchelf -> cargo` (no cycle, cargo doesn't need patchelf on macOS)

Detection occurs **after** platform filtering, so platform-specific cycles only fail on the affected platform.

### Version Conflict Resolution

When multiple dependencies require different versions of the same tool, tsuku uses a **first-encountered wins** strategy during dependency resolution.

#### Resolution Strategy

During transitive dependency resolution, the first version encountered for a tool is selected and used for all subsequent references:

```go
// In resolver.go:396-398
if _, exists := deps[transName]; !exists {
    deps[transName] = transVersion  // First version wins
    newDeps[transName] = transVersion
}
```

**Example**:
```
Tool A depends on cmake@3.20
Tool B depends on cmake@3.25
User runs: tsuku install toolchain (which depends on both A and B)
```

If A is resolved first: cmake@3.20 is selected, B uses cmake@3.20
If B is resolved first: cmake@3.25 is selected, A uses cmake@3.25

#### Rationale

Tsuku's architecture allows multiple tool versions to coexist in `$TSUKU_HOME/tools/` (e.g., cmake-3.20 and cmake-3.25 can both be installed). However, a single installation plan must choose one version to use during the build process.

The first-wins strategy is deterministic (dependency resolution order is alphabetical by name) and simple, avoiding complex version constraint solving.

#### When Version Conflicts Cause Failures

If the selected version is incompatible with a dependent tool's requirements, the build will fail at runtime with tool-specific errors. This is expected behavior - recipe maintainers should ensure dependencies use compatible version constraints.

**Workaround**: Install tools separately rather than as a bundle. Each tool can then use its required version.

### Dependency Deduplication

When multiple tools share the same dependency, tsuku ensures each dependency is installed only once per version.

#### How Deduplication Works

**During plan generation**:
- Each dependency is included in the plan's dependency tree based on recipe requirements
- If Tool A and Tool B both depend on cmake@3.28.1, cmake appears in both dependency subtrees
- The plan structure reflects the logical dependency graph (potentially duplicated)

**During plan execution**:
- The state manager checks if each dependency is already installed before executing its steps
- Check uses tool name + version (e.g., "cmake-3.28.1" in `$TSUKU_HOME/tools/`)
- If installed: skip to next dependency (~10ms overhead for state lookup)
- If not installed: execute installation steps and record in state.json

**Example**:
```
tsuku install ninja           # Installs: cmake@3.28.1, make@4.3, ninja@1.11.1
tsuku install libsixel-source # Plan includes cmake@3.28.1, make@4.3
                              # Execution: skips cmake and make (already installed)
                              # Installs: libsixel-source only
```

This idempotent behavior ensures installing multiple tools with overlapping dependencies is efficient and safe.

### User-Facing Error Messages

The following error scenarios require clear, actionable messages with context:

**Circular Dependency Detection**
```
Error: circular dependency detected during plan generation
  Dependency chain: ninja -> cmake -> ninja

This indicates a recipe configuration error. Check recipe metadata.dependencies fields.
```

**Missing Dependency Recipe**
```
Warning: recipe not found for dependency 'cmake'
  Required by: complex-app (cmake_build action)

If this is a system dependency, install manually. Otherwise: tsuku search cmake
```

**Version Conflict**
```
Error: dependency version conflict
  nodejs@18 required by: tool-a
  nodejs@20 required by: tool-b

Workaround: Install tools separately (they can coexist in $TSUKU_HOME/tools/)
```

**Platform Constraint Violation**
```
Error: dependency 'foo' has no installation steps for platform linux/amd64/alpine
  All steps filtered by platform constraints

This may indicate incompatible platform-specific dependencies.
```

**Resource Limit Exceeded**
```
Error: dependency tree exceeds limits
  Total dependencies: 143 (limit: 100)
  Max depth: 7 (limit: 5)

Deepest chain: app -> lib-a -> lib-b -> lib-c -> lib-d -> lib-e -> lib-f -> lib-g
```

All error messages follow the pattern: error type, specific context, actionable resolution.

### Debugging Plan Generation and Execution

Users can debug issues using these mechanisms:

**Verbose Logging**
```bash
tsuku eval <tool> --verbose       # Detailed plan generation logs
tsuku install --plan plan.json -v # Verbose execution output
```

Verbose mode shows:
- Recipe loading (file path, hash)
- Dependency resolution tree (depth, count)
- Version resolution for each dependency
- Step filtering by platform constraints
- Warnings for missing dependency recipes

**Error Context**
All errors include:
- Operation that failed (plan generation vs execution)
- Tool and dependency chain (e.g., "in dependency cmake → openssl")
- Specific step/action that failed
- Actionable resolution hints

Example error format:
```
Error: failed to resolve dependency version
  Tool: complex-app@2.1.0
  Dependency chain: complex-app → cmake → openssl
  Version provider: github_releases
  Error: GitHub API rate limit exceeded

Hint: Set GITHUB_TOKEN environment variable or retry in 30 minutes
```

**Diagnostic Commands**
- `tsuku plan-info plan.json` - Inspect plan structure and dependency tree
- `tsuku eval <tool> --trace-deps` - Show full dependency resolution trace

## Implementation Approach

### Phase 1: Extend Platform Struct and Add Resource Limits

**Task**: Add `LinuxFamily` field to existing `Platform` struct and design resource limit validation.

**Actions**:
- Extend `Platform` struct in `internal/executor/plan.go` with `LinuxFamily string` field
- Add `json:"linux_family,omitempty"` tag to maintain backward compatibility
- Update `InstallationPlan` to use `Platform` field (verify current field name)
- Design resource limit constants (max dependency depth: 5, max total dependencies: 100)

### Phase 2: Add Platform Validation and Resource Limits

**Task**: Add platform validation to plan execution.

**Changes**:
- Add `LinuxFamily` field to existing `Platform` struct in plan.go
- Update plan generation to populate `Platform.LinuxFamily` field
- Add resource limit constants (max dependency depth: 5, max total dependencies: 100)
- Add `validatePlatform()` function to executor
- Add `validateResourceLimits()` to check dependency tree depth and breadth
- Call validations as first step in `ExecutePlan()`

**Implementation: validatePlatform()**
```go
func validatePlatform(plan *InstallationPlan, currentPlatform Platform) error {
    if plan.Platform.OS != currentPlatform.OS {
        return fmt.Errorf("platform mismatch: plan requires %s, current system is %s",
            plan.Platform.OS, currentPlatform.OS)
    }

    if plan.Platform.Arch != currentPlatform.Arch {
        return fmt.Errorf("architecture mismatch: plan requires %s, current system is %s",
            plan.Platform.Arch, currentPlatform.Arch)
    }

    // Linux family check (only if OS is linux)
    if plan.Platform.OS == "linux" && plan.Platform.LinuxFamily != "" &&
       plan.Platform.LinuxFamily != currentPlatform.LinuxFamily {
        return fmt.Errorf("linux family mismatch: plan requires %s, current system is %s",
            plan.Platform.LinuxFamily, currentPlatform.LinuxFamily)
    }

    return nil
}
```

**Implementation: validateResourceLimits()**
```go
const (
    MaxDependencyDepth = 5
    MaxTotalDependencies = 100
)

func validateResourceLimits(plan *InstallationPlan) error {
    totalDeps := 0
    maxDepth := 0

    var traverse func(deps []DependencyPlan, depth int) error
    traverse = func(deps []DependencyPlan, depth int) error {
        if depth > MaxDependencyDepth {
            return fmt.Errorf("dependency depth exceeds limit (%d > %d)", depth, MaxDependencyDepth)
        }
        if depth > maxDepth {
            maxDepth = depth
        }

        for _, dep := range deps {
            totalDeps++
            if totalDeps > MaxTotalDependencies {
                return fmt.Errorf("total dependencies exceed limit (%d > %d)",
                    totalDeps, MaxTotalDependencies)
            }
            if err := traverse(dep.Dependencies, depth+1); err != nil {
                return err
            }
        }
        return nil
    }

    return traverse(plan.Dependencies, 1)
}
```

**Example errors**:
```
Error: linux family mismatch
  Plan requires: debian
  Current system: alpine

Error: dependency depth exceeds limit (7 > 5)
Tool: deeply-nested-tool
Hint: This may indicate a circular dependency or malicious recipe
```

**Implementation: Missing Dependency Recipe Handling**

When `generateSingleDependencyPlan()` encounters a dependency with no recipe in the registry, it should emit a warning but continue plan generation. This allows for system dependencies (tools expected to be pre-installed) while alerting users to potential configuration errors.

```go
func generateSingleDependencyPlan(cfg *PlanConfig, depName string, depVersion string, processed map[string]bool) (*DependencyPlan, error) {
    // ... existing recipe loading code ...

    if err != nil {
        // Recipe not found - may be a system dependency
        if cfg.OnWarning != nil {
            cfg.OnWarning("dependency",
                fmt.Sprintf("recipe not found for dependency '%s' (version: %s) - assuming system dependency. "+
                    "If this is unexpected, check for typos in recipe metadata.dependencies or action implicit dependencies.",
                    depName, depVersion))
        }
        return nil, nil  // Skip this dependency, continue plan generation
    }

    // ... rest of implementation ...
}
```

**Warning output example**:
```
Warning: recipe not found for dependency 'make' (version: latest) - assuming system dependency.
If this is unexpected, check for typos in recipe metadata.dependencies or action implicit dependencies.
```

**Behavior**:
- Dependencies without recipes are **excluded from the plan**
- The plan executor assumes they are available in the execution environment
- If the dependency is not available at execution time, the installation will fail with a standard "command not found" error

**Rationale for warn-but-continue**:

1. **Ecosystem reality**: Many build tools (`make`, `pkg-config`, `git`, etc.) are commonly pre-installed via system package managers. Requiring recipes for all of them would create unnecessary duplication.

2. **Gradual recipe coverage**: The recipe registry is growing. Missing recipes for some dependencies should not block installation of tools that work with system dependencies.

3. **Clear failure mode**: If a skipped dependency is truly missing, the build will fail at the step that invokes it (e.g., "cmake: command not found"), providing a clear error that users can resolve by installing the system package.

### Phase 3: Enable RecipeLoader and Remove Workarounds (Atomic)

**Important**: Phases 3 and 4 must be combined into a single atomic commit to avoid intermediate broken states.

**File**: `cmd/tsuku/install_deps.go`

**Note on implementation**: The `planRetrievalConfig` struct does not currently have a `RecipeLoader` field. The fix requires:
1. Adding `RecipeLoader actions.RecipeLoader` to the struct definition (cmd/tsuku/install_deps.go:22-31)
2. Passing `loader` when constructing the config (lines ~478-484)
3. Threading the field through to the underlying `executor.PlanConfig` in `getOrGeneratePlanWith()` (line ~120)

This is straightforward wiring work but involves more than "changing line 478" - it requires understanding the two-phase config flow (planRetrievalConfig → PlanConfig).

**Change 1** (lines 22-31, ~120, ~478-484):
```go
// Add to planRetrievalConfig struct:
type planRetrievalConfig struct {
    RecipeLoader actions.RecipeLoader  // NEW: Enable dependency embedding
    // ... existing fields ...
}

// Pass loader when constructing config:
planCfg := planRetrievalConfig{
    RecipeLoader: loader,  // Enable dependency embedding
    // ... other fields ...
}

// Thread through to executor.PlanConfig in getOrGeneratePlanWith():
execCfg := executor.PlanConfig{
    RecipeLoader: cfg.RecipeLoader,  // NEW
    // ... other fields ...
}
```

**Delete 1** (lines 392-395 + function definitions):
```go
// DELETE: ensurePackageManagersForRecipe call (4 lines)
execPaths, err := ensurePackageManagersForRecipe(mgr, r, visited, telemetryClient)
if err != nil {
    return fmt.Errorf("failed to ensure package managers: %w", err)
}

// DELETE: ensurePackageManagersForRecipe function definition (lines 143-195, ~53 lines)
// DELETE: findDependencyBinPath helper function (lines 197-223, ~27 lines)
// Total: 84 lines deleted
```

**Delete 2** (lines 451-475):
```go
// DELETE: SetResolvedDeps workaround (25 lines)
exec.SetResolvedDeps(resolvedDeps)
```

**Total**: ~109 lines deleted (including helper functions), 3-5 lines changed to thread RecipeLoader through config structs (plus platform validation and resource limits added in Phase 2).

### Phase 4: Test Plan Portability

**Test 1: Plans are identical**
```bash
# Generate plan via eval
go build -o tsuku ./cmd/tsuku
./tsuku eval ninja --linux-family debian > plan-eval.json

# Generate plan internally via install (with debug logging to capture plan)
# Compare JSON output - should be identical
diff plan-eval.json plan-install-debug.json
```

**Test 2: Cross-machine execution**
```bash
# Generate plan on host
./tsuku eval ninja --linux-family debian > plan.json

# Execute in fresh container (same platform)
docker run -v $(pwd)/plan.json:/plan.json debian:bookworm-slim \
  /path/to/tsuku install --plan /plan.json

# Verify installation succeeded
docker run -v $(pwd)/plan.json:/plan.json debian:bookworm-slim \
  ninja --version
```

**Test 3: Platform mismatch detection**
```bash
# Generate plan for debian
./tsuku eval ninja --linux-family debian > plan-debian.json

# Try to execute on alpine (should fail fast)
docker run -v $(pwd)/plan-debian.json:/plan.json alpine:latest \
  /path/to/tsuku install --plan /plan.json

# Expected: "Error: linux family mismatch: plan requires debian, current system is alpine"
```

### Phase 5: Validate Sandbox Tests

**Task**: Confirm sandbox tests now validate real execution path.

**Actions**:
- Run existing sandbox tests for recipes with implicit dependencies
- Verify tests pass (dependencies installed from plan, not pre-installed on host)
- Check CI logs to confirm multi-family testing works

## Security Considerations

### Download Verification

**No change from current behavior.**

Dependencies are installed using the same download and verification mechanisms as the main recipe:
- SHA256 checksum verification for all downloaded artifacts
- Checksums embedded in dependency recipes
- Download failure aborts installation

### Execution Isolation

**No change from current behavior.**

- Dependencies are installed to `$TSUKU_HOME/tools/{tool}-{version}/`
- Same isolation model as explicit dependencies
- Sandbox mode still uses container isolation (no additional privileges)

### Supply Chain Risks

**No change from current behavior.**

Implicit dependencies (build tools like `cmake`, `zig`) are installed from the same sources as explicit dependencies:
- Recipes define download sources (GitHub releases, official websites, etc.)
- Same trust model as any tsuku install
- No new external dependencies introduced

The change only affects **when** dependencies are installed (during plan execution instead of before plan generation), not **what** is installed or **how** it's verified.

### User Data Exposure

**Not applicable** - This change does not access or transmit user data.

The only data flowing through the system is:
- Recipe metadata (already public, defined in recipes/)
- Installation plans (generated locally, can be shared but contain no user data)
- Downloaded tool binaries (checksummed, same as current behavior)

### Additional Security Measures

This design introduces mitigations for risks that become more relevant with self-contained plans:

#### Resource Exhaustion (Dependency Bombs)

**Risk**: Malicious recipes could create exponentially-growing dependency trees (e.g., each dependency depends on 10 others, creating 10^n installations).

**Mitigation**: Hard limits on dependency tree depth (max 5 levels) and breadth (max 100 total dependencies). Plans exceeding these limits are rejected before any installation begins. See Phase 2 implementation for `validateResourceLimits()`.

**Residual risk**: Limits are conservative and may need tuning based on real-world usage. Legitimate complex tools might hit the limits (solvable by increasing constants or using explicit dependency management).

#### Platform Validation Bypass

**Risk**: Plans could be executed on incompatible systems if platform information is not validated.

**Mitigation**: Platform validation is mandatory. All plans must include a `Platform` field and execution will fail fast if the current platform doesn't match. See Phase 2 implementation for `validatePlatform()`.

**Residual risk**: Plans without `LinuxFamily` populated will skip Linux family validation (backward compatibility), but this is acceptable since pre-GA plans are rare and users can regenerate plans to get full validation.

#### Plan Tampering

**Risk**: Plans are JSON files that can be modified between `eval` and `install`. Attackers with filesystem access could modify dependency URLs, remove checksums, or inject malicious steps.

**Out of scope for this design** - Plan integrity (signatures, embedded hashes, schema validation) is a broader concern affecting all plan-based execution, not specific to implicit dependencies. This should be addressed in a separate design for plan security.

**Current mitigations** (already exist):
- Checksums are embedded in dependency recipes (modifying plan URL still requires valid checksum)
- Schema validation at plan load time rejects malformed plans
- Plan generation and execution typically happen in same session (limited time window)

**Future work**: Consider cryptographic plan signatures in format v4 or later.

## Migration Path for Pre-GA Users

**What happens to existing plans:**
- Old plan files (format v3 without dependencies) will execute with a warning
- Warning message: "Plan has no dependencies (generated with older tsuku). Implicit dependencies may not be available. Regenerate with: tsuku eval <tool>"
- Installation may fail if implicit dependencies are missing from the system
- No automatic migration or conversion

**What users need to do:**
- Regenerate all saved plan files: `tsuku eval <tool> > plan-new.json`
- Update CI pipelines to use new plans (check for new `dependencies` field)
- Delete old cached plans to avoid confusion
- No action needed if using `tsuku install <tool>` directly (auto-generates new plans)

**Breaking change rationale:**
Since tsuku is pre-GA, we accept this one-time breakage to fix the implicit dependency problem. Users have a clear migration path (regenerate plans), and the new format is strictly better (self-contained).

## Consequences

### Positive

1. **Plans are truly portable**: Generate once on a machine with toolchains, execute anywhere on the same platform
2. **Single code path**: Easier to maintain, test, and reason about (one flow instead of three)
3. **Sandbox tests validate real behavior**: CI tests the same execution path used in production
4. **Format v3 infrastructure proves its value**: Existing implementation just needs to be enabled
5. **Fail-fast platform validation**: Clear error messages when platform mismatches occur
6. **Clean design**: No backward compatibility complexity since tsuku is pre-GA

### Negative

1. **Plan generation may be slower**: Must resolve all dependency versions during plan generation
2. **Plans are larger**: Include full dependency trees instead of being empty
3. **Potential redundant installations**: When eval and install run on the same host, dependencies might be installed twice

### Mitigations

1. **Plan caching already exists**: Slow generation happens once, cached plans are reused
2. **Plan size increase is negligible**: Dependency metadata is small (tool name, version, download URL)
3. **Redundancy is idempotent**: State manager checks if already installed, skips with ~10ms overhead (acceptable cost for correctness guarantee)
