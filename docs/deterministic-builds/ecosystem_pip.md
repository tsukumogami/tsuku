# pip/pipx Ecosystem: Deterministic Execution Investigation

## Executive Summary

The pip/pipx ecosystem provides multiple mechanisms for deterministic package installation through requirements.txt with SHA256 hashes, pip-tools for dependency locking, and the newly accepted PEP 751 lockfile format. While wheels offer strong reproducibility guarantees when combined with hash-checking mode, source distributions (sdist) introduce unavoidable non-determinism through arbitrary setup.py execution and platform-specific compilation. For tsuku's purposes, a pip_install primitive should capture full dependency graphs with hashes at eval time, enforce --require-hashes --no-deps --only-binary :all: during execution, and document residual non-determinism from Python version dependencies and native extensions.

## Lock Mechanism

### requirements.txt with Hash-Checking Mode

The primary lock mechanism in the pip ecosystem is **requirements.txt with SHA256 hashes**. Hash-checking mode uses local hashes embedded in a requirements file to protect against remote tampering and network issues. Hashes are specified using the `--hash` option per requirement.

**Format example:**
```
black==24.10.0 \
    --hash=sha256:1234567890abcdef... \
    --hash=sha256:fedcba0987654321...
click>=8.0.0,<9.0.0 \
    --hash=sha256:abcd1234...
```

**Key characteristics:**
- Hash-checking is **all-or-nothing**: specifying `--hash` for any requirement activates it globally
- All dependencies must be pinned to exact versions (using `==`) or specific URLs/paths
- Multiple hashes per package are allowed (for different platform-specific wheels)
- SHA256 is the recommended algorithm, but stronger ones (from hashlib) are allowed
- Weaker algorithms (md5, sha1, sha224) are excluded for security

### pip-tools (pip-compile)

**pip-tools** provides a higher-level workflow for dependency locking. The `pip-compile` command generates a locked requirements.txt from a requirements.in file (or pyproject.toml).

**Workflow:**
1. Define abstract dependencies in `requirements.in`:
   ```
   black
   requests>=2.25.0
   ```

2. Run `pip-compile --generate-hashes` to produce `requirements.txt`:
   ```
   # This file is autogenerated by pip-compile with Python 3.11
   # by the following command:
   #
   #    pip-compile --generate-hashes requirements.in
   #
   black==24.10.0 \
       --hash=sha256:1234...
   click==8.1.7 \
       --hash=sha256:5678...
   # ... (full dependency tree with hashes)
   ```

**Key features:**
- Resolves full dependency tree automatically
- Pins all transitive dependencies to exact versions
- Can generate hashes for all dependencies
- Supports upgrade workflows (`--upgrade`, `--upgrade-package`)
- Results vary by Python version, platform, and resolver state

### PEP 751: pylock.toml (New Standard - 2025)

**PEP 751** was accepted in 2025 as the standardized Python lockfile format, replacing the rejected PEP 665. Unlike PEP 665 (which was wheels-only), PEP 751 includes support for source distributions with opt-in/opt-out controls.

**Status:**
- Accepted as final in early 2025
- pip 25.1 added `pip lock` command to generate pylock.toml
- Tool authors (Poetry, PDM, uv) have signaled they will implement it as an export format
- Not yet universally adopted as the sole lockfile format

**Format:** TOML-based, includes:
- Full dependency graph
- Hashes for all artifacts (wheels and sdists)
- Python version constraints
- Platform/ABI tags

### Other Lock Formats

- **Pipenv (Pipfile.lock):** JSON format with hashes, used by Pipenv tool
- **Poetry (poetry.lock):** Custom TOML format, used by Poetry
- **PDM (pdm.lock):** Custom TOML format, used by PDM

These are tool-specific and not standardized across the ecosystem.

## Eval-Time Capture

### Efficient Resolution Without Installation

Several approaches exist for resolving dependencies at eval time without performing a full installation:

#### 1. pip-compile (Recommended for tsuku)

```bash
# Generate locked requirements with hashes
pip-compile --generate-hashes \
    --output-file=requirements.txt \
    requirements.in

# Specify Python version for cross-platform resolution
pip-compile --python-version=3.11 \
    --generate-hashes \
    requirements.in
```

**Advantages:**
- Uses pip's dependency resolver (same as actual install)
- Generates full transitive dependency tree
- Includes hashes for all dependencies
- No actual installation performed

**Disadvantages:**
- Requires Python interpreter and pip environment
- Resolution can be slow for large dependency trees
- Results vary by platform unless using `--platform` (experimental)

#### 2. pip download with Inspection

```bash
# Download packages without installing
pip download --no-deps \
    --only-binary :all: \
    --dest ./downloads \
    black==24.10.0

# Then inspect downloaded wheels for metadata
```

**Advantages:**
- Downloads actual artifacts that will be used
- Can verify hashes directly from downloads

**Disadvantages:**
- Still requires downloading packages
- Need to manually resolve dependency tree
- Platform-specific (downloads for current platform only)

#### 3. PyPI JSON API (Limited)

The PyPI JSON API provides package metadata at `https://pypi.org/pypi/{package}/json`.

**Capabilities:**
- Returns metadata for latest version (or specific version at `/pypi/{package}/{version}/json`)
- Includes `requires_dist` for dependencies
- Includes digests (md5, sha256, blake2b_256) for all release files
- Includes wheel tags for platform compatibility

**Limitations:**
- Metadata is at the project level, not per-wheel (unreliable for platform-specific deps)
- Only shows metadata for the queried version (not all versions)
- Not all packages properly declare metadata in JSON API
- PEP 658 (2022) improved this by serving distribution metadata separately, but adoption is incomplete

**Example usage for eval-time dependency capture:**
```python
import requests

# Get package info
resp = requests.get('https://pypi.org/pypi/black/24.10.0/json')
data = resp.json()

# Extract dependencies
requires_dist = data['info'].get('requires_dist', [])

# Extract hashes for wheels
for url_data in data['urls']:
    if url_data['packagetype'] == 'bdist_wheel':
        sha256 = url_data['digests']['sha256']
        url = url_data['url']
        filename = url_data['filename']
```

#### 4. PEP 658 Metadata (Modern Approach)

PEP 658 (accepted 2022) makes wheel metadata available separately from the package. This allows tools to fetch metadata without downloading the entire wheel.

**How it works:**
- PyPI serves `.metadata` files alongside wheels
- Tools can fetch metadata to resolve dependencies before downloading
- Supported by pip and modern package indexes

**Limitations:**
- Requires package index support (PyPI has it, but not all indexes)
- Still requires resolver to handle complex dependency graphs

### Recommended Approach for tsuku

For tsuku's eval-time capture, the recommended approach is:

1. **Use pip-compile** to resolve the full dependency tree with hashes
2. **Parse the generated requirements.txt** to extract:
   - Package specifications (name==version)
   - SHA256 hashes for each artifact
   - Dependencies and constraints
3. **Store in the installation plan** as a complete, locked dependency graph

**Why pip-compile:**
- Most reliable (uses pip's own resolver)
- Generates requirements.txt that can be used directly at exec time
- Includes hashes automatically with `--generate-hashes`
- Widely used and maintained by the community

**Alternative for lighter-weight resolution:**
- Use PyPI JSON API for simple, pure-Python packages with few dependencies
- Fall back to pip-compile for complex dependency trees

## Locked Execution

### Core Flags and Environment Variables

To ensure locked execution respects the captured dependency graph, pip provides several critical flags and environment variables:

#### Essential Flags

**1. `--require-hashes`**
```bash
pip install --require-hashes -r requirements.txt
```
- Forces hash-checking mode globally
- Installation fails if any requirement lacks a hash
- Verifies every downloaded artifact against specified hash
- Detects tampering or supply chain attacks

**2. `--no-deps`**
```bash
pip install --no-deps -r requirements.txt
```
- Disables dependency resolution
- Only installs explicitly listed packages
- Assumes requirements.txt contains full dependency tree
- Prevents pip from fetching unlisted dependencies

**3. `--only-binary :all:`**
```bash
pip install --only-binary :all: -r requirements.txt
```
- Only install from wheels (binary distributions)
- Refuses to build from source distributions (sdist)
- Prevents arbitrary setup.py execution during install
- Critical for security and reproducibility

**Combined safe installation:**
```bash
pip install \
    --require-hashes \
    --no-deps \
    --only-binary :all: \
    -r requirements.txt
```

#### Offline Installation

For fully deterministic offline installation:
```bash
# Download packages at eval time
pip download \
    --require-hashes \
    --only-binary :all: \
    --dest ./packages \
    -r requirements.txt

# Install offline at exec time
pip install \
    --no-index \
    --find-links=./packages \
    --require-hashes \
    --no-deps \
    --only-binary :all: \
    -r requirements.txt
```

**Flags:**
- `--no-index`: Don't use package indexes (PyPI)
- `--find-links=DIR`: Look for archives in directory

### Environment Variables

Key environment variables for controlling pip behavior:

**1. `PIP_REQUIRE_HASHES=1`**
- Equivalent to `--require-hashes` flag
- Useful for enforcing policy across all pip invocations

**2. `PIP_NO_DEPS=1`**
- Equivalent to `--no-deps` flag

**3. `PIP_ONLY_BINARY=:all:`**
- Equivalent to `--only-binary :all:` flag

**4. `PIP_NO_INDEX=1`**
- Disable package index access (offline mode)

**5. `PYTHONHASHSEED=0`**
- Makes Python's hash function deterministic
- Affects bytecode generation order
- Recommended for fully reproducible builds

### pipx-Specific Execution

For pipx (which tsuku currently uses for Python CLI tools), the isolation model involves:

**Environment setup:**
```bash
PIPX_HOME=/path/to/install/dir
PIPX_BIN_DIR=/path/to/install/dir/bin
pipx install black==24.10.0
```

**pipx isolation features:**
- Creates isolated venv per package in `$PIPX_HOME/venvs/<package>/`
- Symlinks executables to `$PIPX_BIN_DIR/`
- Each package gets its own dependency tree
- Prevents version conflicts between tools

**Limitations for deterministic execution:**
- pipx doesn't natively support `--require-hashes`
- No built-in lockfile mechanism
- pipx uses `pip install` internally, so flags can be passed via `--pip-args`:
  ```bash
  pipx install \
      --pip-args="--require-hashes --no-deps --only-binary :all:" \
      -r requirements.txt
  ```

However, this approach is awkward because pipx expects a package name, not a requirements file.

### Recommended Execution Strategy for tsuku

For tsuku's pip_install primitive:

1. **Don't use pipx for locked execution** - use pip directly with venv
2. **Create isolated venv** for each package:
   ```bash
   python -m venv /path/to/install/dir/venvs/<package>
   ```
3. **Install with full safety flags**:
   ```bash
   /path/to/install/dir/venvs/<package>/bin/pip install \
       --require-hashes \
       --no-deps \
       --only-binary :all: \
       -r locked-requirements.txt
   ```
4. **Symlink executables** to bin directory (like pipx does)

This provides the same isolation as pipx while maintaining full control over pip flags for deterministic execution.

## Reproducibility Guarantees

### What pip Guarantees

When using hash-checking mode with wheels-only installation, pip provides strong guarantees:

**1. Artifact Integrity**
- Downloaded packages match specified hashes exactly
- Detects tampering or supply chain attacks
- Cryptographic verification (SHA256)

**2. Version Pinning**
- Exact version installed matches requirements
- No automatic upgrades or resolution
- Transitive dependencies locked

**3. Wheel Consistency**
- Pre-built binaries are bit-for-bit identical across installations
- No compilation variance
- No build-time configuration differences

### What pip Does NOT Guarantee

**1. Source Distribution (sdist) Reproducibility**
- Building from source can vary by:
  - Compiler version
  - Build-time dependencies
  - System libraries
  - Build environment configuration
  - Random/timestamp-based elements in build process
- setup.py can execute arbitrary code
- Different platforms produce different binaries

**2. Cross-Platform Reproducibility**
- Wheels are platform-specific (Linux, macOS, Windows)
- ABI tags vary by Python implementation (CPython, PyPy)
- Architecture-specific builds (x86_64, aarch64, etc.)
- Must generate separate lock files per platform

**3. Python Version Dependencies**
- Wheels are tagged with compatible Python versions
- Some packages only provide wheels for specific Python versions
- Dependency resolution can differ between Python 3.10 vs 3.11
- Must lock against specific Python interpreter version

### Wheels vs Source Distributions

**Wheels (.whl) - Recommended:**
- Pre-built binary distributions
- Platform and Python version specific
- Installation is unzip + metadata update
- No compilation or arbitrary code execution
- Reproducible across identical platform/Python combinations
- Filename encodes platform tags: `{dist}-{version}-{python}-{abi}-{platform}.whl`
  - Example: `black-24.10.0-py3-none-any.whl` (pure Python, any platform)
  - Example: `numpy-1.24.0-cp311-cp311-manylinux_2_17_x86_64.whl` (CPython 3.11, Linux)

**Source Distributions (.tar.gz, .zip) - Avoid:**
- Source code archives
- Require building during installation
- Run setup.py (arbitrary code execution)
- May compile C extensions
- Depend on system compilers, libraries
- Non-reproducible builds

### Manylinux Standard

For Linux wheels, the **manylinux** standard ensures cross-distro compatibility:

- `manylinux_2_17_x86_64`: glibc 2.17+ on x86_64 (covers most modern Linux)
- `manylinux_2_24_x86_64`: glibc 2.24+ (newer baseline)
- `manylinux1`, `manylinux2010`, `manylinux2014`: older, deprecated standards

Wheels tagged with manylinux can run on most Linux distributions, avoiding the need for distro-specific builds.

### Platform Compatibility Tags (PEP 425)

Wheel filenames encode compatibility via tags:

**Python tag:** `py3`, `cp39`, `cp311`, `py2.py3`
- `py3`: Any Python 3.x
- `cp311`: CPython 3.11 specifically
- `py2.py3`: Python 2 or 3 (rare now)

**ABI tag:** `none`, `cp39`, `cp311`, `abi3`
- `none`: No ABI dependency (pure Python)
- `cp311`: CPython 3.11 ABI
- `abi3`: Stable ABI (compatible across Python versions)

**Platform tag:** `any`, `manylinux_2_17_x86_64`, `macosx_11_0_arm64`, `win_amd64`
- `any`: Pure Python, platform-independent
- Platform-specific otherwise

**Installation compatibility:**
- pip checks running interpreter's tags against wheel tags
- Only installs compatible wheels
- Falls back to sdist if no compatible wheel (unless `--only-binary :all:`)

## Residual Non-Determinism

Even with best practices, some sources of non-determinism remain:

### 1. Python Interpreter Version

**Issue:** Different Python versions may:
- Resolve dependencies differently
- Have different standard library contents
- Support different wheel ABIs
- Produce different bytecode (.pyc files)

**Impact:** High - can cause installation failures or runtime differences

**Mitigation:**
- Lock against specific Python version (e.g., "requires-python = '==3.11.7'")
- Generate separate lock files per Python version
- Use python-standalone for controlled Python distribution

### 2. Platform and Architecture

**Issue:** Wheels are platform-specific. Installing on Linux vs macOS vs Windows may:
- Select different wheels
- Have different available packages (some only publish wheels for certain platforms)
- Behave differently due to OS-specific code paths

**Impact:** High - fundamentally different execution environments

**Mitigation:**
- Generate platform-specific lock files
- Use `pip-compile --platform=` for cross-platform locking (experimental)
- Accept that each platform requires separate validation

### 3. Native Extensions and C Libraries

**Issue:** Packages with C extensions:
- Link against system libraries (OpenSSL, zlib, etc.)
- May use different library versions across systems
- ABI compatibility is not always verified correctly (see abi3audit tool)

**Impact:** Medium - mostly affects packages with native code

**Mitigation:**
- Prefer pure-Python packages when possible
- Use `--only-binary :all:` to avoid building from source
- Test on target platform

### 4. Wheel Availability Changes

**Issue:** PyPI package authors can:
- Yanked releases (marked unavailable but not deleted)
- Add new platform-specific wheels after release
- Remove old releases
- Change metadata without version bumps (rare, but possible)

**Impact:** Low - pip respects hashes, will fail if artifact changes

**Mitigation:**
- Hash-checking mode detects changes
- Consider vendoring wheels for critical dependencies
- Use private package index for enterprise

### 5. Timestamp and Build Metadata

**Issue:** Some packages embed:
- Build timestamps in metadata
- Random values in wheel contents
- Non-deterministic file ordering (fixed in wheel package now)

**Impact:** Very Low - doesn't affect functionality, only checksums

**Mitigation:**
- Modern wheel package makes builds reproducible
- PEP 517/518 build backends improving reproducibility
- Not a concern for tsuku (we check hashes at download time, not build time)

### 6. Transitive Dependency Updates

**Issue:** If a lock file uses loose constraints:
- Transitive deps could update
- Hash mismatches would fail installation

**Impact:** None if using `--require-hashes` and `--no-deps`

**Mitigation:**
- Always use `--require-hashes` and `--no-deps` together
- Lock all transitive dependencies with exact versions

### 7. pip Resolver Behavior Changes

**Issue:** Different pip versions may resolve dependencies differently, especially:
- Before pip 20.3 (old resolver)
- After pip 20.3 (new backtracking resolver)

**Impact:** Low - affects lock generation, not installation from lock

**Mitigation:**
- Use modern pip (>=20.3) for resolution
- Lock file captures resolved state, so pip version at install time matters less

## Recommended Primitive Interface

Based on the investigation, here's the proposed `pip_install` primitive for tsuku:

```go
// PipInstallParams defines parameters for the pip_install primitive.
// This primitive represents the decomposition barrier for Python packages.
// It captures the full dependency tree at eval time and executes a locked
// installation at exec time.
type PipInstallParams struct {
    // Package is the primary package name (e.g., "black").
    // This is informational; actual installation uses LockedRequirements.
    Package string `json:"package"`

    // Version is the primary package version (e.g., "24.10.0").
    // This is informational; actual installation uses LockedRequirements.
    Version string `json:"version"`

    // Executables lists the expected binary names to verify and symlink.
    // After installation, these must exist in the venv/bin directory.
    Executables []string `json:"executables"`

    // LockedRequirements contains the full requirements.txt content with:
    // - All packages pinned to exact versions (package==version)
    // - SHA256 hashes for all packages (--hash=sha256:...)
    // - All transitive dependencies included
    // Generated at eval time via pip-compile --generate-hashes.
    LockedRequirements string `json:"locked_requirements"`

    // PythonVersion is the exact Python version required (e.g., "3.11.7").
    // Must match the python-standalone version used by tsuku.
    PythonVersion string `json:"python_version"`

    // PythonInterpreter is the path to the Python interpreter to use.
    // Typically resolves to tsuku's python-standalone installation.
    // If empty, uses system Python (not recommended for reproducibility).
    PythonInterpreter string `json:"python_interpreter,omitempty"`

    // Platform specifies the target platform for wheel selection.
    // Format: "os-arch" (e.g., "linux-amd64", "darwin-arm64")
    // Used to validate that the locked requirements match the execution environment.
    Platform string `json:"platform"`

    // ExtraIndexURLs specifies additional package indexes to search.
    // Empty for most cases (defaults to PyPI only).
    // Only needed for private package indexes.
    ExtraIndexURLs []string `json:"extra_index_urls,omitempty"`
}

// PipInstallLocks captures the locked state generated at eval time.
// Embedded in the installation plan to ensure reproducibility.
type PipInstallLocks struct {
    // RequirementsHash is SHA256 of LockedRequirements content.
    // Used to detect if requirements changed between eval and exec.
    RequirementsHash string `json:"requirements_hash"`

    // ResolvedAt is the timestamp when dependencies were resolved.
    // Informational only (not used for reproducibility).
    ResolvedAt time.Time `json:"resolved_at"`

    // PipVersion is the pip version used for resolution.
    // Informational; warns if exec-time pip differs significantly.
    PipVersion string `json:"pip_version"`

    // PackageCount is the number of packages in the locked requirements.
    // Used for validation and reporting.
    PackageCount int `json:"package_count"`
}

// Example plan step:
{
    "action": "pip_install",
    "params": {
        "package": "black",
        "version": "24.10.0",
        "executables": ["black", "blackd"],
        "locked_requirements": "black==24.10.0 \\\n    --hash=sha256:1234... \\\n    --hash=sha256:5678...\nclick==8.1.7 \\\n    --hash=sha256:abcd...\n...",
        "python_version": "3.11.7",
        "python_interpreter": "/home/user/.tsuku/tools/python-standalone-3.11.7/bin/python3",
        "platform": "linux-amd64"
    },
    "locks": {
        "requirements_hash": "sha256:deadbeef...",
        "resolved_at": "2025-12-12T10:00:00Z",
        "pip_version": "25.1.0",
        "package_count": 12
    },
    "deterministic": false
}
```

### Execution Implementation

At exec time, the primitive performs:

1. **Verify Python interpreter:**
   ```go
   cmd := exec.Command(params.PythonInterpreter, "--version")
   // Verify output matches params.PythonVersion
   ```

2. **Create isolated venv:**
   ```go
   venvDir := filepath.Join(installDir, "venvs", params.Package)
   cmd := exec.Command(params.PythonInterpreter, "-m", "venv", venvDir)
   ```

3. **Write locked requirements to temp file:**
   ```go
   reqFile := filepath.Join(venvDir, "requirements.txt")
   os.WriteFile(reqFile, []byte(params.LockedRequirements), 0644)
   ```

4. **Install with safety flags:**
   ```go
   pipBin := filepath.Join(venvDir, "bin", "pip")
   cmd := exec.Command(
       pipBin, "install",
       "--require-hashes",
       "--no-deps",
       "--only-binary", ":all:",
       "-r", reqFile,
   )
   ```

5. **Verify executables:**
   ```go
   for _, exe := range params.Executables {
       exePath := filepath.Join(venvDir, "bin", exe)
       if _, err := os.Stat(exePath); err != nil {
           return fmt.Errorf("executable %s not found", exe)
       }
   }
   ```

6. **Create symlinks to bin directory:**
   ```go
   for _, exe := range params.Executables {
       src := filepath.Join("..", "venvs", params.Package, "bin", exe)
       dst := filepath.Join(installDir, "bin", exe)
       os.Symlink(src, dst)
   }
   ```

### Why Not pipx?

While tsuku currently uses pipx (see `/home/dangazineu/dev/workspace/tsuku/tsuku-4/public/tsuku/internal/actions/pipx_install.go`), it's not suitable for fully deterministic execution because:

- pipx doesn't expose `--require-hashes` and `--no-deps` easily
- pipx resolves dependencies at install time, not eval time
- pipx doesn't support lockfile-based installation
- No way to pre-capture the full dependency graph

**Recommendation:** Migrate from pipx_install to pip_install primitive that uses pip directly with venv isolation. This provides the same isolation model as pipx while enabling deterministic execution.

## Security Considerations

The pip/pipx ecosystem has several security-critical areas:

### 1. Arbitrary Code Execution (setup.py)

**Risk: CRITICAL**

Source distributions (sdist) contain a `setup.py` file that executes arbitrary Python code during installation. This happens even with `pip download` (not just `pip install`).

**Attack vectors:**
- Typosquatting: Registering packages with similar names to popular packages (e.g., "requsts" instead of "requests")
- Compromised maintainer accounts
- Malicious package updates
- Supply chain attacks

**Real-world incidents:**
- Multiple malicious packages discovered on PyPI executing spyware, info-stealers, and trojans
- setup.py used to download second-stage payloads from external URLs
- Base64-encoded payloads in setup.py to evade static analysis

**Mitigation in tsuku:**
- **ALWAYS use `--only-binary :all:`** to refuse source distributions
- Fail installation if no wheel is available (don't silently fall back to sdist)
- Never run `python setup.py install` directly
- Document to users that only packages with wheels are supported

### 2. Hash Verification and Supply Chain Integrity

**Risk: HIGH**

Without hash verification, pip trusts:
- Package index (PyPI) not to serve different content
- TLS/certificate authority chain
- DNS resolution

**Attack vectors:**
- Compromised PyPI account → malicious package update
- Yanked-and-replaced releases
- Man-in-the-middle attacks (TLS required by PyPI, but still a risk)

**Mitigation in tsuku:**
- **ALWAYS use `--require-hashes`** for reproducible installations
- Compute hashes at eval time by downloading packages
- Store hashes in installation plan
- Fail if exec-time hash doesn't match eval-time hash
- This detects supply chain attacks where package content changes

### 3. Dependency Confusion

**Risk: MEDIUM**

Dependency confusion occurs when:
- Private and public package indexes are both configured
- Attacker registers public package with same name as private package
- pip might install public (malicious) package instead of private one

**Mitigation in tsuku:**
- Default to PyPI only (no extra indexes)
- If extra indexes needed, use `--index-url` (replaces default) not `--extra-index-url` (adds to default)
- Document risks to users configuring extra indexes

### 4. Wheel Metadata Spoofing

**Risk: MEDIUM**

Wheels are ZIP files containing:
- Compiled code (.so, .pyd files for C extensions)
- Pure Python code (.py files)
- Metadata (WHEEL, METADATA files)

**Attack vectors:**
- ABI tag spoofing: Wheel claims to be `abi3` (stable ABI) but isn't
- Platform tag lying: Wheel claims to support a platform but doesn't
- Hidden native code: Pure Python wheel (py3-none-any) secretly includes platform-specific behavior

**Mitigation in tsuku:**
- Hash verification catches modified wheels
- Platform tag validation ensures wheel matches target platform
- No automatic fix for ABI spoofing (ecosystem-wide problem)
- abi3audit tool exists but not widely adopted

### 5. Transitive Dependency Attacks

**Risk: MEDIUM**

Package A depends on package B, which depends on malicious package C.

**Attack vectors:**
- Compromised indirect dependency
- Abandoned packages taken over by attackers
- Typosquatting in transitive dependencies

**Mitigation in tsuku:**
- Lock ALL transitive dependencies with hashes
- Use `--no-deps` to prevent pip from resolving unlisted dependencies
- Audit locked requirements.txt before accepting into plan

### 6. PyPI Account Compromise

**Risk: HIGH (ecosystem-wide)

PyPI maintainer accounts can be compromised via:
- Weak passwords
- Phishing
- Credential reuse

Once compromised, attackers can upload malicious releases.

**Mitigation in tsuku:**
- Hash verification detects changed packages
- Recommend users audit packages before first install
- No automatic fix (depends on PyPI security)

### 7. Installation-Time Network Attacks

**Risk: LOW (with TLS)

During `pip install`, network requests could be intercepted.

**Mitigation:**
- PyPI requires TLS (HTTPS)
- Hash verification ensures downloaded content matches expected
- Offline installation mode (`--no-index --find-links`) eliminates network risk

### Security Best Practices for tsuku

1. **Eval-time:**
   - Download packages to compute hashes
   - Use pip-compile to resolve dependencies (not manual listing)
   - Audit resolved dependencies (show user what will be installed)
   - Store full requirements.txt with hashes in plan

2. **Exec-time:**
   - ALWAYS: `--require-hashes --no-deps --only-binary :all:`
   - Verify Python interpreter before use
   - Isolate in venv (one per package)
   - Fail loudly on any hash mismatch
   - Never fall back to source distributions

3. **Documentation:**
   - Warn users about supply chain risks
   - Recommend auditing packages before install
   - Document that only wheel-compatible packages are supported
   - Explain why some packages can't be installed deterministically

4. **Version validation:**
   - Validate version strings against PEP 440 format
   - Prevent command injection via version field (current pipx_install.go already does this)
   - Sanitize all user inputs used in pip commands

## Implementation Recommendations

### 1. Migrate from pipx_install to pip_install Primitive

**Current state:** `/home/dangazineu/dev/workspace/tsuku/tsuku-4/public/tsuku/internal/actions/pipx_install.go` uses pipx for installation.

**Issues with current approach:**
- No hash verification
- No dependency locking
- pipx resolves dependencies at install time (non-deterministic)
- Can't capture full dependency graph at eval time

**Recommended changes:**
- Implement new `pip_install` primitive (decomposition barrier)
- Use pip directly with venv isolation (same isolation model as pipx)
- Implement eval-time dependency resolution via pip-compile
- Capture full locked requirements with hashes
- Execute with `--require-hashes --no-deps --only-binary :all:`

### 2. Eval-Time Dependency Resolution

**Approach:**

```go
// PipInstallAction.Decompose() implementation
func (a *PipInstallAction) Decompose(ctx *EvalContext, params map[string]interface{}) ([]Step, error) {
    package := params["package"].(string)
    version := ctx.Version
    executables := params["executables"].([]string)

    // Step 1: Create temporary requirements.in
    reqIn := fmt.Sprintf("%s==%s\n", package, version)

    // Step 2: Run pip-compile to resolve dependencies with hashes
    // This requires a temporary Python environment with pip-tools installed
    cmd := exec.Command(
        "pip-compile",
        "--generate-hashes",
        "--output-file=-",  // Write to stdout
        "--no-header",      // Skip comment header
        "-",                // Read from stdin
    )
    cmd.Stdin = strings.NewReader(reqIn)
    output, err := cmd.CombinedOutput()
    if err != nil {
        return nil, fmt.Errorf("pip-compile failed: %w\nOutput: %s", err, output)
    }

    lockedRequirements := string(output)

    // Step 3: Parse locked requirements to count packages, validate format
    packageCount := parsePackageCount(lockedRequirements)

    // Step 4: Get Python interpreter path and version
    pythonPath := ResolvePythonStandalone()
    pythonVersion := getPythonVersion(pythonPath)

    // Step 5: Return primitive step with locks
    return []Step{
        {
            Action: "pip_install",
            Params: map[string]interface{}{
                "package":             package,
                "version":             version,
                "executables":         executables,
                "locked_requirements": lockedRequirements,
                "python_version":      pythonVersion,
                "python_interpreter":  pythonPath,
                "platform":            fmt.Sprintf("%s-%s", ctx.OS, ctx.Arch),
            },
            Locks: map[string]interface{}{
                "requirements_hash": sha256Sum(lockedRequirements),
                "resolved_at":       time.Now(),
                "pip_version":       getPipVersion(pythonPath),
                "package_count":     packageCount,
            },
        },
    }, nil
}
```

**Requirements:**
- Tsuku needs pip-tools available at eval time (could be self-hosted via tsuku install pip-tools)
- Alternative: Implement resolution in Go by calling PyPI JSON API (more complex, less reliable)

### 3. Exec-Time Installation

```go
// PipInstallPrimitive.Execute() implementation
func (p *PipInstallPrimitive) Execute(ctx *ExecutionContext, params PipInstallParams) error {
    // Step 1: Verify Python interpreter
    if err := verifyPythonVersion(params.PythonInterpreter, params.PythonVersion); err != nil {
        return err
    }

    // Step 2: Create venv
    venvDir := filepath.Join(ctx.InstallDir, "venvs", params.Package)
    if err := createVenv(params.PythonInterpreter, venvDir); err != nil {
        return err
    }

    // Step 3: Write requirements.txt
    reqFile := filepath.Join(venvDir, "requirements.txt")
    if err := os.WriteFile(reqFile, []byte(params.LockedRequirements), 0644); err != nil {
        return err
    }

    // Step 4: Verify requirements hash (detect tampering)
    actualHash := sha256Sum(params.LockedRequirements)
    if actualHash != params.Locks.RequirementsHash {
        return fmt.Errorf("requirements hash mismatch: expected %s, got %s",
            params.Locks.RequirementsHash, actualHash)
    }

    // Step 5: Install with safety flags
    pipBin := filepath.Join(venvDir, "bin", "pip")
    cmd := exec.Command(
        pipBin, "install",
        "--require-hashes",
        "--no-deps",
        "--only-binary", ":all:",
        "--disable-pip-version-check",
        "-r", reqFile,
    )
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    if err := cmd.Run(); err != nil {
        return fmt.Errorf("pip install failed: %w", err)
    }

    // Step 6: Verify executables exist
    for _, exe := range params.Executables {
        exePath := filepath.Join(venvDir, "bin", exe)
        if _, err := os.Stat(exePath); err != nil {
            return fmt.Errorf("expected executable %s not found", exe)
        }
    }

    // Step 7: Create symlinks
    binDir := filepath.Join(ctx.InstallDir, "bin")
    for _, exe := range params.Executables {
        src := filepath.Join("..", "venvs", params.Package, "bin", exe)
        dst := filepath.Join(binDir, exe)
        if err := os.Symlink(src, dst); err != nil {
            return fmt.Errorf("failed to symlink %s: %w", exe, err)
        }
    }

    return nil
}
```

### 4. Platform-Specific Lock Files

For cross-platform support, tsuku needs to handle platform-specific wheels:

**Options:**

**A. Generate locks per-platform at eval time:**
- Run pip-compile with `--platform=linux_x86_64`, `--platform=macosx_arm64`, etc.
- Store multiple LockedRequirements in plan (one per platform)
- Select appropriate one at exec time based on runtime platform

**B. Platform detection at eval time, single lock:**
- Only generate lock for current platform
- Plans are platform-specific
- User must re-evaluate on each target platform

**Recommendation:** Option B (single platform per plan) for initial implementation. Option A for future enhancement.

### 5. Python Version Management

**Challenge:** Different Python versions may have different dependency resolutions and available wheels.

**Solution:**
- Always use python-standalone from tsuku
- Lock Python version in plan
- Fail if exec-time Python version doesn't match eval-time version

**Implementation:**
```go
func verifyPythonVersion(pythonPath string, expectedVersion string) error {
    cmd := exec.Command(pythonPath, "--version")
    output, err := cmd.CombinedOutput()
    if err != nil {
        return err
    }

    actual := parseVersionFromOutput(output)  // "Python 3.11.7" -> "3.11.7"
    if actual != expectedVersion {
        return fmt.Errorf("Python version mismatch: plan requires %s, but found %s",
            expectedVersion, actual)
    }
    return nil
}
```

### 6. Handling Missing Wheels

**Issue:** Some packages don't provide wheels for all platforms.

**Options:**

**A. Fail loudly (Recommended):**
- If `--only-binary :all:` fails, report error to user
- Suggest alternatives or filing issue with package maintainer

**B. Allow per-package sdist exception:**
- Add `allow_source_for` parameter
- Only for trusted, pure-Python packages
- Still verify hashes

**C. Build wheels at eval time:**
- Download sdist and build wheel locally
- Cache built wheel
- Include in plan
- Complex, security risks from setup.py execution

**Recommendation:** Option A for initial implementation. Option B as escape hatch for well-known pure-Python packages if needed.

### 7. Integration with Existing Recipes

**Current pipx_install usage:**

```toml
[[versions]]
pattern = "*"

[versions.install]
action = "pipx_install"
package = "black"
executables = ["black", "blackd"]
```

**Migration path:**

1. Keep `pipx_install` action as composite action
2. Add `Decompose()` method that returns `pip_install` primitive
3. Recipes unchanged
4. Plan contains `pip_install` primitive (not `pipx_install`)

```go
func (a *PipxInstallAction) Decompose(ctx *EvalContext, params map[string]interface{}) ([]Step, error) {
    // Delegate to PipInstallAction decomposition
    pipInstall := &PipInstallAction{}
    return pipInstall.Decompose(ctx, params)
}
```

This maintains backward compatibility while enabling deterministic execution.

### 8. Error Handling and User Feedback

**Key scenarios:**

**Eval time:**
- Dependency resolution fails → Show pip-compile error, suggest version constraints
- No wheels available → List missing wheels, suggest `--allow-source` or alternatives
- Network failures → Retry with backoff, cache intermediate results

**Exec time:**
- Hash mismatch → CRITICAL, fail immediately, warn about supply chain attack
- Python version mismatch → Show expected vs actual, suggest re-eval or update interpreter
- Missing executable → Fail with helpful message (package installed but binary missing)

**Logging:**
```
[eval] Resolving dependencies for black==24.10.0...
[eval] Resolved 12 packages with hashes
[eval] Total download size: 2.4 MB
[eval] ✓ Dependency resolution complete

[exec] Installing black==24.10.0 with 11 dependencies
[exec] Creating isolated environment...
[exec] Installing packages (--require-hashes --no-deps --only-binary :all:)...
[exec] ✓ Installed black 24.10.0
[exec] ✓ Verified executables: black, blackd
```

### 9. Testing Strategy

**Unit tests:**
- Test `Decompose()` with various packages
- Mock pip-compile output
- Test hash verification
- Test version validation

**Integration tests:**
- Install real packages (black, ruff, etc.)
- Verify executables work
- Test plan serialization/deserialization
- Test cross-version compatibility

**Security tests:**
- Attempt hash tampering (should fail)
- Test with malicious requirements.txt (should reject)
- Test version string injection (should sanitize)

**Platform tests:**
- Test on Linux, macOS, Windows (if supported)
- Test different Python versions
- Test manylinux wheels

### 10. Documentation for Users

**Recipe authoring guide:**
```markdown
## Python CLI Tools

Use the `pipx_install` action for Python command-line tools:

toml
[versions.install]
action = "pipx_install"
package = "black"
executables = ["black", "blackd"]


### Requirements

- Package must be available on PyPI
- Package must provide wheels for your platform
- If no wheel available, installation will fail

### Platform Support

Python packages are installed using wheels, which are platform-specific.
Tsuku generates platform-specific installation plans. To install on a
different platform, re-run `tsuku eval` on that platform.

### Security

Tsuku uses hash-checking mode to verify package integrity. All dependencies
are locked at evaluation time with cryptographic hashes. If a package is
modified on PyPI after evaluation, installation will fail with a hash
mismatch error.
```

---

## Sources

- [Secure installs - pip documentation v25.3](https://pip.pypa.io/en/stable/topics/secure-installs/)
- [pip hash - pip documentation v25.3](https://pip.pypa.io/en/stable/cli/pip_hash/)
- [pip-tools GitHub Repository](https://github.com/jazzband/pip-tools)
- [Generating a Fully-Qualified and Hashed Python Requirements File](https://www.peterdebelak.com/blog/generating-a-fully-qualified-and-hashed-requirements-file/)
- [Python Dependency Locking with pip-tools](https://lincolnloop.com/blog/python-dependency-locking-pip-tools/)
- [Dependency Resolution - pip documentation v25.3](https://pip.pypa.io/en/stable/topics/dependency-resolution/)
- [What Are Python Wheels and Why Should You Care? – Real Python](https://realpython.com/python-wheels/)
- [pip download - pip documentation v25.3](https://pip.pypa.io/en/stable/cli/pip_download/)
- [Package Formats - Python Packaging User Guide](https://packaging.python.org/en/latest/discussions/package-formats/)
- [GitHub - pypa/pipx: Install and Run Python Applications in Isolated Environments](https://github.com/pypa/pipx)
- [How pipx works - pipx](https://pipx.pypa.io/stable/how-pipx-works/)
- [JSON API - PyPI Docs](https://docs.pypi.org/api/json/)
- [PEP 691 – JSON-based Simple API for Python Package Indexes](https://peps.python.org/pep-0691/)
- [Metadata handling on PyPI - pypackaging-native](https://pypackaging-native.github.io/key-issues/pypi_metadata_handling/)
- [Malicious Python Packages and Code Execution via pip download](https://embracethered.com/blog/posts/2022/python-package-manager-install-and-download-vulnerability/)
- [The security risks of pip and PyPI](https://carles-garcia.net/python/python_pip/)
- [Arbitrary Code Execution During Python Package Installation](https://medium.com/ochrona/arbitrary-code-execution-during-python-package-installation-3a60990350ef)
- [Platform compatibility tags - Python Packaging User Guide](https://packaging.python.org/en/latest/specifications/platform-compatibility-tags/)
- [ABI compatibility in Python: How hard could it be?](https://blog.trailofbits.com/2022/11/15/python-wheels-abi-abi3audit/)
- [PEP 665 – A file format to list Python dependencies for reproducibility of an application](https://peps.python.org/pep-0665/)
- [PEP 751 – A file format to record Python dependencies for installation reproducibility](https://peps.python.org/pep-0751/)
- [Python now has a standard package lock file format](https://devclass.com/2025/04/04/python-now-has-a-standard-package-lock-file-format-though-winning-full-adoption-will-be-a-challenge/)
- [Repeatable Installs - pip documentation v25.3](https://pip.pypa.io/en/stable/topics/repeatable-installs/)
- [What's new in pip 25.1 - Dependency groups!](https://ichard26.github.io/blog/2025/04/whats-new-in-pip-25.1/)
