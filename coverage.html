
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>telemetry: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tsuku-dev/tsuku/internal/telemetry/client.go (91.3%)</option>
				
				<option value="file1">github.com/tsuku-dev/tsuku/internal/telemetry/event.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package telemetry

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "time"
)

const (
        // EnvNoTelemetry disables telemetry when set to any non-empty value.
        EnvNoTelemetry = "TSUKU_NO_TELEMETRY"

        // EnvDebug enables debug mode: prints events to stderr without sending.
        EnvDebug = "TSUKU_TELEMETRY_DEBUG"

        // DefaultEndpoint is the URL where telemetry events are sent.
        DefaultEndpoint = "https://telemetry.tsuku.dev/event"

        // DefaultTimeout is the HTTP request timeout.
        DefaultTimeout = 2 * time.Second
)

// Client sends telemetry events. It is safe for concurrent use.
type Client struct {
        endpoint string
        timeout  time.Duration
        disabled bool
        debug    bool
}

// NewClient creates a telemetry client.
// It checks TSUKU_NO_TELEMETRY and TSUKU_TELEMETRY_DEBUG environment variables.
func NewClient() *Client <span class="cov8" title="1">{
        return &amp;Client{
                endpoint: DefaultEndpoint,
                timeout:  DefaultTimeout,
                disabled: os.Getenv(EnvNoTelemetry) != "",
                debug:    os.Getenv(EnvDebug) != "",
        }
}</span>

// NewClientWithOptions creates a telemetry client with custom options.
// This is primarily useful for testing.
func NewClientWithOptions(endpoint string, timeout time.Duration, disabled, debug bool) *Client <span class="cov8" title="1">{
        return &amp;Client{
                endpoint: endpoint,
                timeout:  timeout,
                disabled: disabled,
                debug:    debug,
        }
}</span>

// IsDisabled returns true if telemetry is disabled.
func (c *Client) IsDisabled() bool <span class="cov8" title="1">{
        return c.disabled
}</span>

// Send sends an event asynchronously. It never blocks and never returns errors.
// If telemetry is disabled, this is a no-op.
// If debug mode is enabled, the event is printed to stderr instead of being sent.
func (c *Client) Send(event Event) <span class="cov8" title="1">{
        if c.disabled </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if c.debug </span><span class="cov8" title="1">{
                data, _ := json.Marshal(event)
                fmt.Fprintf(os.Stderr, "[telemetry] %s\n", data)
                return
        }</span>

        // Fire-and-forget: spawn goroutine, no waiting
        <span class="cov8" title="1">go c.send(event)</span>
}

// send performs the actual HTTP request. Called in a goroutine by Send.
func (c *Client) send(event Event) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), c.timeout)
        defer cancel()

        data, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return // Silent failure
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.endpoint, bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return // Silent failure
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return // Silent failure (timeout, network error, etc.)
        }</span>
        <span class="cov8" title="1">resp.Body.Close()</span>
        // Ignore response status - we don't retry
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package telemetry provides anonymous usage telemetry for tsuku.
package telemetry

import (
        "runtime"

        "github.com/tsuku-dev/tsuku/internal/buildinfo"
)

// Event represents a telemetry event sent to the backend.
type Event struct {
        Action            string `json:"action"`             // "install", "update", or "remove"
        Recipe            string `json:"recipe"`             // Recipe name (e.g., "nodejs")
        VersionConstraint string `json:"version_constraint"` // User's original constraint (e.g., "@LTS", "&gt;=1.0", or empty)
        VersionResolved   string `json:"version_resolved"`   // Actual version installed/updated to
        VersionPrevious   string `json:"version_previous"`   // Previous version (for update/remove)
        OS                string `json:"os"`                 // Operating system ("linux", "darwin")
        Arch              string `json:"arch"`               // CPU architecture ("amd64", "arm64")
        TsukuVersion      string `json:"tsuku_version"`      // Version of tsuku CLI
        IsDependency      bool   `json:"is_dependency"`      // True if installed as a transitive dependency
        SchemaVersion     string `json:"schema_version"`     // Event schema version
}

const schemaVersion = "1"

// newBaseEvent creates an event with common fields pre-filled.
func newBaseEvent() Event <span class="cov8" title="1">{
        return Event{
                OS:            runtime.GOOS,
                Arch:          runtime.GOARCH,
                TsukuVersion:  buildinfo.Version(),
                SchemaVersion: schemaVersion,
        }
}</span>

// NewInstallEvent creates a telemetry event for an install action.
func NewInstallEvent(recipe, versionConstraint, versionResolved string, isDependency bool) Event <span class="cov8" title="1">{
        e := newBaseEvent()
        e.Action = "install"
        e.Recipe = recipe
        e.VersionConstraint = versionConstraint
        e.VersionResolved = versionResolved
        e.IsDependency = isDependency
        return e
}</span>

// NewUpdateEvent creates a telemetry event for an update action.
func NewUpdateEvent(recipe, versionPrevious, versionResolved string) Event <span class="cov8" title="1">{
        e := newBaseEvent()
        e.Action = "update"
        e.Recipe = recipe
        e.VersionPrevious = versionPrevious
        e.VersionResolved = versionResolved
        return e
}</span>

// NewRemoveEvent creates a telemetry event for a remove action.
func NewRemoveEvent(recipe, versionPrevious string) Event <span class="cov8" title="1">{
        e := newBaseEvent()
        e.Action = "remove"
        e.Recipe = recipe
        e.VersionPrevious = versionPrevious
        return e
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
