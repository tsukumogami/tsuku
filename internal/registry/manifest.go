package registry

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
)

const (
	// DefaultManifestURL is the default URL for the registry manifest.
	// The manifest is a JSON file containing recipe metadata (name, description,
	// dependencies, satisfies) generated by scripts/generate-registry.py.
	DefaultManifestURL = "https://tsuku.dev/recipes.json"

	// EnvManifestURL is the environment variable to override the manifest URL.
	EnvManifestURL = "TSUKU_MANIFEST_URL"

	// manifestCacheFile is the filename for the cached manifest within CacheDir.
	manifestCacheFile = "manifest.json"
)

// Manifest represents the registry manifest (recipes.json).
type Manifest struct {
	SchemaVersion string           `json:"schema_version"`
	GeneratedAt   string           `json:"generated_at"`
	Recipes       []ManifestRecipe `json:"recipes"`
}

// ManifestRecipe represents a single recipe entry in the manifest.
type ManifestRecipe struct {
	Name                string              `json:"name"`
	Description         string              `json:"description"`
	Homepage            string              `json:"homepage"`
	Dependencies        []string            `json:"dependencies"`
	RuntimeDependencies []string            `json:"runtime_dependencies"`
	Satisfies           map[string][]string `json:"satisfies,omitempty"`
}

// manifestURL returns the URL for the registry manifest.
func manifestURL() string {
	if url := os.Getenv(EnvManifestURL); url != "" {
		return url
	}
	return DefaultManifestURL
}

// FetchManifest fetches the registry manifest from the network and caches it locally.
// Returns the parsed manifest, or an error if the fetch or parse fails.
func (r *Registry) FetchManifest(ctx context.Context) (*Manifest, error) {
	url := manifestURL()

	// Handle local filesystem manifest (for testing)
	if isLocalPath(url) {
		return r.readLocalManifest(url)
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create manifest request: %w", err)
	}

	resp, err := r.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch manifest: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("manifest fetch returned status %d", resp.StatusCode)
	}

	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read manifest response: %w", err)
	}

	manifest, err := parseManifest(data)
	if err != nil {
		return nil, err
	}

	// Cache the raw JSON for future use
	if r.CacheDir != "" {
		cachePath := filepath.Join(r.CacheDir, manifestCacheFile)
		if mkErr := os.MkdirAll(r.CacheDir, 0755); mkErr == nil {
			_ = os.WriteFile(cachePath, data, 0644) // Best-effort cache
		}
	}

	return manifest, nil
}

// GetCachedManifest reads the locally cached manifest without network access.
// Returns nil, nil if no cached manifest exists.
func (r *Registry) GetCachedManifest() (*Manifest, error) {
	if r.CacheDir == "" {
		return nil, nil
	}

	cachePath := filepath.Join(r.CacheDir, manifestCacheFile)
	data, err := os.ReadFile(cachePath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to read cached manifest: %w", err)
	}

	return parseManifest(data)
}

// readLocalManifest reads a manifest from a local filesystem path.
func (r *Registry) readLocalManifest(path string) (*Manifest, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read local manifest: %w", err)
	}
	return parseManifest(data)
}

// parseManifest parses raw JSON bytes into a Manifest struct.
func parseManifest(data []byte) (*Manifest, error) {
	var manifest Manifest
	if err := json.Unmarshal(data, &manifest); err != nil {
		return nil, fmt.Errorf("failed to parse manifest JSON: %w", err)
	}
	return &manifest, nil
}
