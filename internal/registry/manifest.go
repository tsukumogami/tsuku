package registry

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
)

const (
	// manifestCacheFile is the filename for the cached manifest within CacheDir.
	manifestCacheFile = "manifest.json"

	// DefaultManifestURL is the default URL for the registry manifest.
	// The manifest is generated by scripts/generate-registry.py and deployed
	// to the tsuku.dev website alongside the marketing site.
	DefaultManifestURL = "https://tsuku.dev/recipes.json"

	// EnvManifestURL is the environment variable to override the manifest URL.
	EnvManifestURL = "TSUKU_MANIFEST_URL"
)

// Manifest represents the registry manifest (recipes.json).
type Manifest struct {
	SchemaVersion string           `json:"schema_version"`
	GeneratedAt   string           `json:"generated_at"`
	Recipes       []ManifestRecipe `json:"recipes"`
}

// ManifestRecipe represents a single recipe entry in the manifest.
type ManifestRecipe struct {
	Name                string              `json:"name"`
	Description         string              `json:"description"`
	Homepage            string              `json:"homepage"`
	Dependencies        []string            `json:"dependencies"`
	RuntimeDependencies []string            `json:"runtime_dependencies"`
	Satisfies           map[string][]string `json:"satisfies,omitempty"`
}

// GetCachedManifest reads the locally cached manifest without network access.
// Returns nil, nil if no cached manifest exists.
func (r *Registry) GetCachedManifest() (*Manifest, error) {
	if r.CacheDir == "" {
		return nil, nil
	}

	cachePath := filepath.Join(r.CacheDir, manifestCacheFile)
	data, err := os.ReadFile(cachePath)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to read cached manifest: %w", err)
	}

	return parseManifest(data)
}

// manifestURL returns the URL for the registry manifest.
// Checks TSUKU_MANIFEST_URL environment variable first, then falls back
// to DefaultManifestURL. For local registries, constructs a filesystem path.
func (r *Registry) manifestURL() string {
	if envURL := os.Getenv(EnvManifestURL); envURL != "" {
		return envURL
	}
	if r.isLocal {
		return filepath.Join(r.BaseURL, "_site", "recipes.json")
	}
	return DefaultManifestURL
}

// FetchManifest fetches the registry manifest from the remote URL (or local
// filesystem) and caches it in CacheDir. Returns the parsed manifest.
func (r *Registry) FetchManifest(ctx context.Context) (*Manifest, error) {
	url := r.manifestURL()

	var data []byte
	var err error

	if r.isLocal {
		data, err = os.ReadFile(url)
		if err != nil {
			return nil, fmt.Errorf("failed to read manifest from local registry: %w", err)
		}
	} else {
		req, reqErr := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
		if reqErr != nil {
			return nil, &RegistryError{
				Type:    ErrTypeNetwork,
				Recipe:  "manifest",
				Message: "failed to create manifest request",
				Err:     reqErr,
			}
		}

		resp, doErr := r.client.Do(req)
		if doErr != nil {
			return nil, WrapNetworkError(doErr, "manifest", "failed to fetch manifest")
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			return nil, &RegistryError{
				Type:    ErrTypeNetwork,
				Recipe:  "manifest",
				Message: fmt.Sprintf("manifest fetch returned status %d", resp.StatusCode),
			}
		}

		data, err = io.ReadAll(resp.Body)
		if err != nil {
			return nil, &RegistryError{
				Type:    ErrTypeParsing,
				Recipe:  "manifest",
				Message: "failed to read manifest content",
				Err:     err,
			}
		}
	}

	// Validate that the data is valid JSON before caching
	manifest, parseErr := parseManifest(data)
	if parseErr != nil {
		return nil, parseErr
	}

	// Cache the raw data
	if cacheErr := r.CacheManifest(data); cacheErr != nil {
		// Log warning but don't fail -- we have the data in memory
		fmt.Fprintf(os.Stderr, "Warning: failed to cache manifest: %v\n", cacheErr)
	}

	return manifest, nil
}

// CacheManifest writes the raw manifest data to the cache directory.
func (r *Registry) CacheManifest(data []byte) error {
	if r.CacheDir == "" {
		return fmt.Errorf("cache directory not set")
	}

	if err := os.MkdirAll(r.CacheDir, 0755); err != nil {
		return fmt.Errorf("failed to create cache directory: %w", err)
	}

	cachePath := filepath.Join(r.CacheDir, manifestCacheFile)
	if err := os.WriteFile(cachePath, data, 0644); err != nil {
		return fmt.Errorf("failed to write manifest cache: %w", err)
	}

	return nil
}

// parseManifest parses raw JSON bytes into a Manifest struct.
func parseManifest(data []byte) (*Manifest, error) {
	var manifest Manifest
	if err := json.Unmarshal(data, &manifest); err != nil {
		return nil, fmt.Errorf("failed to parse manifest JSON: %w", err)
	}
	return &manifest, nil
}
