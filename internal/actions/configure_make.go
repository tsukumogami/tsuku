package actions

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

// ConfigureMakeAction builds software using autotools (./configure && make install).
// This is an ecosystem primitive that cannot be decomposed further.
type ConfigureMakeAction struct{ BaseAction }

// IsDeterministic returns false because autotools builds depend on system compilers.

// Name returns the action name
func (a *ConfigureMakeAction) Name() string {
	return "configure_make"
}

// Dependencies returns the dependencies needed for configure_make builds.
// Install-time dependencies are make (for building), zig (as C compiler), and pkg-config (for library discovery).
func (ConfigureMakeAction) Dependencies() ActionDeps {
	return ActionDeps{InstallTime: []string{"make", "zig", "pkg-config"}}
}

// Execute builds software using autotools
//
// Parameters:
//   - source_dir (required): Directory containing configure script
//   - configure_args (optional): Arguments to pass to ./configure
//   - make_targets (optional): Make targets to run (default: ["", "install"])
//   - executables (required): List of executable names to verify
//   - prefix (optional): Installation prefix (default: install_dir)
//
// The action runs:
//  1. ./configure --prefix=<install_dir> [configure_args...]
//  2. make [make_targets[0]]
//  3. make install (or make_targets[1:])
//
// Directory Structure Created:
//
//	<install_dir>/
//	  bin/<executable>     - Compiled binary
//	  lib/                 - Libraries (if any)
//	  include/             - Headers (if any)
func (a *ConfigureMakeAction) Execute(ctx *ExecutionContext, params map[string]interface{}) error {
	// Get source directory (required)
	sourceDir, ok := GetString(params, "source_dir")
	if !ok {
		return fmt.Errorf("configure_make action requires 'source_dir' parameter")
	}

	// Resolve source directory relative to work directory if not absolute
	if !filepath.IsAbs(sourceDir) {
		sourceDir = filepath.Join(ctx.WorkDir, sourceDir)
	}

	// Verify configure script exists
	configureScript := filepath.Join(sourceDir, "configure")
	if _, err := os.Stat(configureScript); err != nil {
		return fmt.Errorf("configure script not found at %s: %w", configureScript, err)
	}

	// Get executables list (required)
	executables, ok := GetStringSlice(params, "executables")
	if !ok || len(executables) == 0 {
		return fmt.Errorf("configure_make action requires 'executables' parameter with at least one executable")
	}

	// Validate executable names to prevent path traversal
	for _, exe := range executables {
		if strings.Contains(exe, "/") || strings.Contains(exe, "\\") ||
			strings.Contains(exe, "..") || exe == "." || exe == "" {
			return fmt.Errorf("invalid executable name '%s': must not contain path separators", exe)
		}
	}

	// Get optional parameters
	configureArgs, _ := GetStringSlice(params, "configure_args")
	makeTargets, _ := GetStringSlice(params, "make_targets")

	// Validate configure args for security before any output
	for _, arg := range configureArgs {
		if !isValidConfigureArg(arg) {
			return fmt.Errorf("invalid configure argument '%s'", arg)
		}
	}

	// Default make targets: build (empty target) then install
	if len(makeTargets) == 0 {
		makeTargets = []string{"", "install"}
	}

	// Get prefix (defaults to install_dir)
	prefix := ctx.InstallDir
	if p, ok := GetString(params, "prefix"); ok {
		prefix = p
	}

	fmt.Printf("   Source: %s\n", sourceDir)
	fmt.Printf("   Prefix: %s\n", prefix)
	fmt.Printf("   Executables: %v\n", executables)
	if len(configureArgs) > 0 {
		fmt.Printf("   Configure args: %v\n", configureArgs)
	}

	// Build environment
	env := buildAutotoolsEnv(ctx)

	// Step 1: Run ./configure
	fmt.Printf("   Running: ./configure --prefix=%s\n", prefix)
	args := []string{"--prefix=" + prefix}
	args = append(args, configureArgs...)

	configCmd := exec.CommandContext(ctx.Context, configureScript, args...)
	configCmd.Dir = sourceDir
	configCmd.Env = env

	configOutput, err := configCmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("configure failed: %w\nOutput: %s", err, string(configOutput))
	}

	// Touch autogenerated files to prevent make from trying to regenerate them.
	// This must happen AFTER configure, because configure may generate files like
	// version.texi that are included by other source files. If we touch before
	// configure, those generated files would be newer than our touched timestamps.
	touchAutogeneratedFiles(sourceDir)

	// Step 2: Run make targets
	// Prefer system make if available, as it's more likely to work correctly
	// in minimal containers where Homebrew bottles may have dynamic linking issues
	makePath := findMake()

	// Common make arguments to prevent documentation regeneration
	// MAKEINFO=true prevents makeinfo invocation (for .texi -> .info)
	commonMakeArgs := []string{"MAKEINFO=true"}

	for _, target := range makeTargets {
		var makeArgs []string
		makeArgs = append(makeArgs, commonMakeArgs...)
		if target != "" {
			makeArgs = append(makeArgs, target)
			fmt.Printf("   Running: make %s\n", target)
		} else {
			fmt.Printf("   Running: make\n")
		}

		makeCmd := exec.CommandContext(ctx.Context, makePath, makeArgs...)
		makeCmd.Dir = sourceDir
		makeCmd.Env = env

		makeOutput, err := makeCmd.CombinedOutput()
		if err != nil {
			return fmt.Errorf("make %s failed: %w\nOutput: %s", target, err, string(makeOutput))
		}
	}

	// Step 3: Verify executables exist
	binDir := filepath.Join(prefix, "bin")
	for _, exe := range executables {
		exePath := filepath.Join(binDir, exe)
		if _, err := os.Stat(exePath); err != nil {
			return fmt.Errorf("expected executable %s not found at %s", exe, exePath)
		}
	}

	fmt.Printf("   Build completed successfully\n")
	fmt.Printf("   Installed %d executable(s)\n", len(executables))

	return nil
}

// buildAutotoolsEnv creates an environment for autotools builds.
// It sets PKG_CONFIG_PATH, CPPFLAGS, and LDFLAGS from dependency paths.
func buildAutotoolsEnv(ctx *ExecutionContext) []string {
	env := os.Environ()

	// Set deterministic build variables
	filteredEnv := make([]string, 0, len(env))
	for _, e := range env {
		// Filter variables that could cause non-determinism
		if !strings.HasPrefix(e, "SOURCE_DATE_EPOCH=") &&
			!strings.HasPrefix(e, "PKG_CONFIG_PATH=") &&
			!strings.HasPrefix(e, "CPPFLAGS=") &&
			!strings.HasPrefix(e, "LDFLAGS=") {
			filteredEnv = append(filteredEnv, e)
		}
	}

	// Set SOURCE_DATE_EPOCH for reproducible builds
	filteredEnv = append(filteredEnv, "SOURCE_DATE_EPOCH=0")

	// Build paths from dependencies
	var pkgConfigPaths []string
	var cppFlags []string
	var ldFlags []string

	// Iterate over install-time dependencies to build paths
	for depName, depVersion := range ctx.Dependencies.InstallTime {
		// Construct dependency directory: $TSUKU_HOME/tools/{name}-{version}
		depDir := filepath.Join(ctx.ToolsDir, depName+"-"+depVersion)

		// PKG_CONFIG_PATH: check for lib/pkgconfig directory
		pkgConfigDir := filepath.Join(depDir, "lib", "pkgconfig")
		if _, err := os.Stat(pkgConfigDir); err == nil {
			pkgConfigPaths = append(pkgConfigPaths, pkgConfigDir)
		}

		// CPPFLAGS: check for include directory
		includeDir := filepath.Join(depDir, "include")
		if _, err := os.Stat(includeDir); err == nil {
			cppFlags = append(cppFlags, "-I"+includeDir)
		}

		// LDFLAGS: check for lib directory
		libDir := filepath.Join(depDir, "lib")
		if _, err := os.Stat(libDir); err == nil {
			ldFlags = append(ldFlags, "-L"+libDir)
		}
	}

	// Set PKG_CONFIG_PATH if any paths found
	if len(pkgConfigPaths) > 0 {
		filteredEnv = append(filteredEnv, "PKG_CONFIG_PATH="+strings.Join(pkgConfigPaths, ":"))
	}

	// Set CPPFLAGS if any flags found
	if len(cppFlags) > 0 {
		filteredEnv = append(filteredEnv, "CPPFLAGS="+strings.Join(cppFlags, " "))
	}

	// Set LDFLAGS if any flags found
	if len(ldFlags) > 0 {
		filteredEnv = append(filteredEnv, "LDFLAGS="+strings.Join(ldFlags, " "))
	}

	// Set up C compiler if not using system compiler
	if !hasSystemCompiler() {
		if newEnv, found := SetupCCompilerEnv(filteredEnv); found {
			filteredEnv = newEnv
		}
	}

	return filteredEnv
}

// isValidConfigureArg validates configure arguments for security.
// Allows common argument patterns while rejecting shell metacharacters.
func isValidConfigureArg(arg string) bool {
	if arg == "" || len(arg) > 500 {
		return false
	}

	// Must not contain shell metacharacters
	shellChars := []string{";", "&", "|", "`", "$", "(", ")", "{", "}", "<", ">", "\n", "\r"}
	for _, char := range shellChars {
		if strings.Contains(arg, char) {
			return false
		}
	}

	return true
}

// findMake returns the path to make, preferring system make over tsuku-installed make.
// This is important in minimal containers where Homebrew bottles may have dynamic
// linking issues, but system make works correctly.
func findMake() string {
	// Check common system locations first
	systemPaths := []string{"/usr/bin/make", "/bin/make", "/usr/local/bin/make"}
	for _, p := range systemPaths {
		if _, err := os.Stat(p); err == nil {
			return p
		}
	}
	// Fall back to PATH lookup
	return "make"
}

// touchAutogeneratedFiles updates timestamps on autogenerated files to prevent
// make from trying to regenerate them. GNU source tarballs often have timestamp
// issues that cause make to invoke autotools even when they're not available.
func touchAutogeneratedFiles(sourceDir string) {
	// First, set all source files to a base time
	baseTime := time.Now().Add(-time.Hour)

	// Touch source files to base time
	_ = filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}
		if info.IsDir() {
			return nil
		}
		name := info.Name()
		// Source files that generate other files
		if strings.HasSuffix(name, ".ac") || // configure.ac
			strings.HasSuffix(name, ".am") || // Makefile.am
			strings.HasSuffix(name, ".m4") || // m4 macros
			strings.HasSuffix(name, ".l") || // lex source -> .c
			strings.HasSuffix(name, ".y") || // yacc source -> .c
			strings.HasSuffix(name, ".texi") { // Texinfo source -> .info
			_ = os.Chtimes(path, baseTime, baseTime)
		}
		return nil
	})

	// Generated files should be newer than source files
	genTime := time.Now()

	// List of top-level autogenerated files to touch
	files := []string{
		"configure",
		"aclocal.m4",
		"config.h.in",
		"config.h.in~",
		"autoconf.h.in", // Some projects use this name
		"config.status", // Generated by configure, must be newer than configure
		"config.log",    // Generated by configure
		"Makefile",      // Generated by config.status
	}

	// Touch top-level generated files
	for _, f := range files {
		path := filepath.Join(sourceDir, f)
		if _, err := os.Stat(path); err == nil {
			_ = os.Chtimes(path, genTime, genTime)
		}
	}

	// Touch all generated files recursively
	_ = filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}
		if info.IsDir() {
			return nil
		}
		name := info.Name()
		// Generated files that shouldn't be regenerated
		if strings.HasSuffix(name, "Makefile.in") ||
			name == "Makefile" || // Generated from Makefile.in by config.status
			strings.HasSuffix(name, ".info") ||
			strings.HasSuffix(name, ".h.in") { // config.h.in, autoconf.h.in, etc.
			_ = os.Chtimes(path, genTime, genTime)
		}
		return nil
	})
}
